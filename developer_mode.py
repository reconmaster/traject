#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sun Nov 23 10:37:22 2014 by generateDS.py version 2.13a.
#
# Command line options:
#   ('--export', 'write')
#   ('-o', 'developer_mode.py')
#   ('-s', 'developer_modes_subs.py')
#
# Command line arguments:
#   DeveloperModeSchema.xsd
#
# Command line:
#   /home/amdavis/.local/bin/generateDS.py --export="write" -o "developer_mode.py" -s "developer_modes_subs.py" DeveloperModeSchema.xsd
#
# Current working directory (os.getcwd()):
#   traject
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class VarianResearchBeam(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SchemaVersion=None, Scale=None, SetBeam=None):
        self.original_tagname_ = None
        self.SchemaVersion = _cast(None, SchemaVersion)
        self.Scale = _cast(None, Scale)
        self.SetBeam = SetBeam
    def factory(*args_, **kwargs_):
        if VarianResearchBeam.subclass:
            return VarianResearchBeam.subclass(*args_, **kwargs_)
        else:
            return VarianResearchBeam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SetBeam(self): return self.SetBeam
    def set_SetBeam(self, SetBeam): self.SetBeam = SetBeam
    def get_SchemaVersion(self): return self.SchemaVersion
    def set_SchemaVersion(self, SchemaVersion): self.SchemaVersion = SchemaVersion
    def get_Scale(self): return self.Scale
    def set_Scale(self, Scale): self.Scale = Scale
    def validate_ResearchBeamVersion(self, value):
        # Validate type ResearchBeamVersion, a restriction on xs:string.
        pass
    def validate_Scale(self, value):
        # Validate type Scale, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.SetBeam is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VarianResearchBeam', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VarianResearchBeam')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VarianResearchBeam', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VarianResearchBeam'):
        if self.SchemaVersion is not None and 'SchemaVersion' not in already_processed:
            already_processed.add('SchemaVersion')
            outfile.write(' SchemaVersion=%s' % (quote_attrib(self.SchemaVersion), ))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.add('Scale')
            outfile.write(' Scale=%s' % (quote_attrib(self.Scale), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VarianResearchBeam', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SetBeam is not None:
            self.SetBeam.export(outfile, level, namespace_, name_='SetBeam', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('SchemaVersion', node)
        if value is not None and 'SchemaVersion' not in already_processed:
            already_processed.add('SchemaVersion')
            self.SchemaVersion = value
            self.validate_ResearchBeamVersion(self.SchemaVersion)    # validate type ResearchBeamVersion
        value = find_attr_value_('Scale', node)
        if value is not None and 'Scale' not in already_processed:
            already_processed.add('Scale')
            self.Scale = value
            self.validate_Scale(self.Scale)    # validate type Scale
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SetBeam':
            obj_ = SetBeam.factory()
            obj_.build(child_)
            self.SetBeam = obj_
            obj_.original_tagname_ = 'SetBeam'
# end class VarianResearchBeam


class SetBeam(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SchemaVersion=None, Id=None, GUID=None, TreatmentMode=None, MLCModel=None, Tracking=None, TolTable=None, VelTable=None, Accs=None, ControlPoints=None, ImagingParameters=None, BeamHoldDevices=None):
        self.original_tagname_ = None
        self.SchemaVersion = SchemaVersion
        self.Id = Id
        self.GUID = GUID
        self.TreatmentMode = TreatmentMode
        self.MLCModel = MLCModel
        self.Tracking = Tracking
        self.TolTable = TolTable
        self.VelTable = VelTable
        self.Accs = Accs
        self.ControlPoints = ControlPoints
        self.ImagingParameters = ImagingParameters
        self.BeamHoldDevices = BeamHoldDevices
    def factory(*args_, **kwargs_):
        if SetBeam.subclass:
            return SetBeam.subclass(*args_, **kwargs_)
        else:
            return SetBeam(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SchemaVersion(self): return self.SchemaVersion
    def set_SchemaVersion(self, SchemaVersion): self.SchemaVersion = SchemaVersion
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_GUID(self): return self.GUID
    def set_GUID(self, GUID): self.GUID = GUID
    def get_TreatmentMode(self): return self.TreatmentMode
    def set_TreatmentMode(self, TreatmentMode): self.TreatmentMode = TreatmentMode
    def get_MLCModel(self): return self.MLCModel
    def set_MLCModel(self, MLCModel): self.MLCModel = MLCModel
    def get_Tracking(self): return self.Tracking
    def set_Tracking(self, Tracking): self.Tracking = Tracking
    def get_TolTable(self): return self.TolTable
    def set_TolTable(self, TolTable): self.TolTable = TolTable
    def get_VelTable(self): return self.VelTable
    def set_VelTable(self, VelTable): self.VelTable = VelTable
    def get_Accs(self): return self.Accs
    def set_Accs(self, Accs): self.Accs = Accs
    def get_ControlPoints(self): return self.ControlPoints
    def set_ControlPoints(self, ControlPoints): self.ControlPoints = ControlPoints
    def get_ImagingParameters(self): return self.ImagingParameters
    def set_ImagingParameters(self, ImagingParameters): self.ImagingParameters = ImagingParameters
    def get_BeamHoldDevices(self): return self.BeamHoldDevices
    def set_BeamHoldDevices(self, BeamHoldDevices): self.BeamHoldDevices = BeamHoldDevices
    def validate_TreatmentModeType(self, value):
        # Validate type TreatmentModeType, a restriction on xs:string.
        pass
    def validate_MLCModelType(self, value):
        # Validate type MLCModelType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.SchemaVersion is not None or
            self.Id is not None or
            self.GUID is not None or
            self.TreatmentMode is not None or
            self.MLCModel is not None or
            self.Tracking is not None or
            self.TolTable is not None or
            self.VelTable is not None or
            self.Accs is not None or
            self.ControlPoints is not None or
            self.ImagingParameters is not None or
            self.BeamHoldDevices is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SetBeam', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SetBeam')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SetBeam', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SetBeam'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SetBeam', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SchemaVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSchemaVersion>%s</%sSchemaVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.SchemaVersion).encode(ExternalEncoding), input_name='SchemaVersion'), namespace_, eol_))
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_integer(self.Id, input_name='Id'), namespace_, eol_))
        if self.GUID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGUID>%s</%sGUID>%s' % (namespace_, self.gds_format_string(quote_xml(self.GUID).encode(ExternalEncoding), input_name='GUID'), namespace_, eol_))
        if self.TreatmentMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTreatmentMode>%s</%sTreatmentMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.TreatmentMode).encode(ExternalEncoding), input_name='TreatmentMode'), namespace_, eol_))
        if self.MLCModel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMLCModel>%s</%sMLCModel>%s' % (namespace_, self.gds_format_string(quote_xml(self.MLCModel).encode(ExternalEncoding), input_name='MLCModel'), namespace_, eol_))
        if self.Tracking is not None:
            self.Tracking.export(outfile, level, namespace_, name_='Tracking', pretty_print=pretty_print)
        if self.TolTable is not None:
            self.TolTable.export(outfile, level, namespace_, name_='TolTable', pretty_print=pretty_print)
        if self.VelTable is not None:
            self.VelTable.export(outfile, level, namespace_, name_='VelTable', pretty_print=pretty_print)
        if self.Accs is not None:
            self.Accs.export(outfile, level, namespace_, name_='Accs', pretty_print=pretty_print)
        if self.ControlPoints is not None:
            self.ControlPoints.export(outfile, level, namespace_, name_='ControlPoints', pretty_print=pretty_print)
        if self.ImagingParameters is not None:
            self.ImagingParameters.export(outfile, level, namespace_, name_='ImagingParameters', pretty_print=pretty_print)
        if self.BeamHoldDevices is not None:
            self.BeamHoldDevices.export(outfile, level, namespace_, name_='BeamHoldDevices', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SchemaVersion':
            SchemaVersion_ = child_.text
            SchemaVersion_ = self.gds_validate_string(SchemaVersion_, node, 'SchemaVersion')
            self.SchemaVersion = SchemaVersion_
        elif nodeName_ == 'Id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Id')
            self.Id = ival_
        elif nodeName_ == 'GUID':
            GUID_ = child_.text
            GUID_ = self.gds_validate_string(GUID_, node, 'GUID')
            self.GUID = GUID_
        elif nodeName_ == 'TreatmentMode':
            TreatmentMode_ = child_.text
            TreatmentMode_ = self.gds_validate_string(TreatmentMode_, node, 'TreatmentMode')
            self.TreatmentMode = TreatmentMode_
            self.validate_TreatmentModeType(self.TreatmentMode)    # validate type TreatmentModeType
        elif nodeName_ == 'MLCModel':
            MLCModel_ = child_.text
            MLCModel_ = self.gds_validate_string(MLCModel_, node, 'MLCModel')
            self.MLCModel = MLCModel_
            self.validate_MLCModelType(self.MLCModel)    # validate type MLCModelType
        elif nodeName_ == 'Tracking':
            obj_ = TrackingType.factory()
            obj_.build(child_)
            self.Tracking = obj_
            obj_.original_tagname_ = 'Tracking'
        elif nodeName_ == 'TolTable':
            obj_ = TolTableType.factory()
            obj_.build(child_)
            self.TolTable = obj_
            obj_.original_tagname_ = 'TolTable'
        elif nodeName_ == 'VelTable':
            obj_ = VelTableType.factory()
            obj_.build(child_)
            self.VelTable = obj_
            obj_.original_tagname_ = 'VelTable'
        elif nodeName_ == 'Accs':
            obj_ = AccsType.factory()
            obj_.build(child_)
            self.Accs = obj_
            obj_.original_tagname_ = 'Accs'
        elif nodeName_ == 'ControlPoints':
            obj_ = ControlPointsType.factory()
            obj_.build(child_)
            self.ControlPoints = obj_
            obj_.original_tagname_ = 'ControlPoints'
        elif nodeName_ == 'ImagingParameters':
            obj_ = ImagingParametersType.factory()
            obj_.build(child_)
            self.ImagingParameters = obj_
            obj_.original_tagname_ = 'ImagingParameters'
        elif nodeName_ == 'BeamHoldDevices':
            obj_ = BeamHoldDevicesType.factory()
            obj_.build(child_)
            self.BeamHoldDevices = obj_
            obj_.original_tagname_ = 'BeamHoldDevices'
# end class SetBeam


class Acquisition(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AcquisitionId=None, AcquisitionSpecs=None, AcquisitionParameters=None):
        self.original_tagname_ = None
        self.AcquisitionId = AcquisitionId
        self.AcquisitionSpecs = AcquisitionSpecs
        self.AcquisitionParameters = AcquisitionParameters
    def factory(*args_, **kwargs_):
        if Acquisition.subclass:
            return Acquisition.subclass(*args_, **kwargs_)
        else:
            return Acquisition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AcquisitionId(self): return self.AcquisitionId
    def set_AcquisitionId(self, AcquisitionId): self.AcquisitionId = AcquisitionId
    def get_AcquisitionSpecs(self): return self.AcquisitionSpecs
    def set_AcquisitionSpecs(self, AcquisitionSpecs): self.AcquisitionSpecs = AcquisitionSpecs
    def get_AcquisitionParameters(self): return self.AcquisitionParameters
    def set_AcquisitionParameters(self, AcquisitionParameters): self.AcquisitionParameters = AcquisitionParameters
    def hasContent_(self):
        if (
            self.AcquisitionId is not None or
            self.AcquisitionSpecs is not None or
            self.AcquisitionParameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Acquisition', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Acquisition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Acquisition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Acquisition'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Acquisition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AcquisitionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAcquisitionId>%s</%sAcquisitionId>%s' % (namespace_, self.gds_format_integer(self.AcquisitionId, input_name='AcquisitionId'), namespace_, eol_))
        if self.AcquisitionSpecs is not None:
            self.AcquisitionSpecs.export(outfile, level, namespace_, name_='AcquisitionSpecs', pretty_print=pretty_print)
        if self.AcquisitionParameters is not None:
            self.AcquisitionParameters.export(outfile, level, namespace_, name_='AcquisitionParameters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AcquisitionId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AcquisitionId')
            self.AcquisitionId = ival_
        elif nodeName_ == 'AcquisitionSpecs':
            obj_ = AcquisitionSpecsType.factory()
            obj_.build(child_)
            self.AcquisitionSpecs = obj_
            obj_.original_tagname_ = 'AcquisitionSpecs'
        elif nodeName_ == 'AcquisitionParameters':
            obj_ = AcquisitionParametersType.factory()
            obj_.build(child_)
            self.AcquisitionParameters = obj_
            obj_.original_tagname_ = 'AcquisitionParameters'
# end class Acquisition


class ArmPositionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SpecialPosition=None, Positions=None):
        self.original_tagname_ = None
        self.SpecialPosition = SpecialPosition
        self.Positions = Positions
    def factory(*args_, **kwargs_):
        if ArmPositionsType.subclass:
            return ArmPositionsType.subclass(*args_, **kwargs_)
        else:
            return ArmPositionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SpecialPosition(self): return self.SpecialPosition
    def set_SpecialPosition(self, SpecialPosition): self.SpecialPosition = SpecialPosition
    def get_Positions(self): return self.Positions
    def set_Positions(self, Positions): self.Positions = Positions
    def validate_SpecialPositionType(self, value):
        # Validate type SpecialPositionType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.SpecialPosition is not None or
            self.Positions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ArmPositionsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArmPositionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ArmPositionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArmPositionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ArmPositionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SpecialPosition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSpecialPosition>%s</%sSpecialPosition>%s' % (namespace_, self.gds_format_string(quote_xml(self.SpecialPosition).encode(ExternalEncoding), input_name='SpecialPosition'), namespace_, eol_))
        if self.Positions is not None:
            self.Positions.export(outfile, level, namespace_, name_='Positions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SpecialPosition':
            SpecialPosition_ = child_.text
            SpecialPosition_ = self.gds_validate_string(SpecialPosition_, node, 'SpecialPosition')
            self.SpecialPosition = SpecialPosition_
            self.validate_SpecialPositionType(self.SpecialPosition)    # validate type SpecialPositionType
        elif nodeName_ == 'Positions':
            obj_ = PositionsType3.factory()
            obj_.build(child_)
            self.Positions = obj_
            obj_.original_tagname_ = 'Positions'
# end class ArmPositionsType


class ArmTolerances(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Lat=None, Lng=None, Vrt=None, Pitch=None):
        self.original_tagname_ = None
        self.Lat = Lat
        self.Lng = Lng
        self.Vrt = Vrt
        self.Pitch = Pitch
    def factory(*args_, **kwargs_):
        if ArmTolerances.subclass:
            return ArmTolerances.subclass(*args_, **kwargs_)
        else:
            return ArmTolerances(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Lat(self): return self.Lat
    def set_Lat(self, Lat): self.Lat = Lat
    def get_Lng(self): return self.Lng
    def set_Lng(self, Lng): self.Lng = Lng
    def get_Vrt(self): return self.Vrt
    def set_Vrt(self, Vrt): self.Vrt = Vrt
    def get_Pitch(self): return self.Pitch
    def set_Pitch(self, Pitch): self.Pitch = Pitch
    def hasContent_(self):
        if (
            self.Lat is not None or
            self.Lng is not None or
            self.Vrt is not None or
            self.Pitch is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ArmTolerances', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArmTolerances')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ArmTolerances', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArmTolerances'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ArmTolerances', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Lat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLat>%s</%sLat>%s' % (namespace_, self.gds_format_double(self.Lat, input_name='Lat'), namespace_, eol_))
        if self.Lng is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLng>%s</%sLng>%s' % (namespace_, self.gds_format_double(self.Lng, input_name='Lng'), namespace_, eol_))
        if self.Vrt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVrt>%s</%sVrt>%s' % (namespace_, self.gds_format_double(self.Vrt, input_name='Vrt'), namespace_, eol_))
        if self.Pitch is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPitch>%s</%sPitch>%s' % (namespace_, self.gds_format_double(self.Pitch, input_name='Pitch'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Lat':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Lat')
            self.Lat = fval_
        elif nodeName_ == 'Lng':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Lng')
            self.Lng = fval_
        elif nodeName_ == 'Vrt':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Vrt')
            self.Vrt = fval_
        elif nodeName_ == 'Pitch':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Pitch')
            self.Pitch = fval_
# end class ArmTolerances


class AcquisitionTrigger(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TriggerDelay=None, TriggerOnEnter=None, TriggerOnExit=None, SingleTrigger=None, extensiontype_=None):
        self.original_tagname_ = None
        self.TriggerDelay = TriggerDelay
        self.TriggerOnEnter = TriggerOnEnter
        self.TriggerOnExit = TriggerOnExit
        self.SingleTrigger = SingleTrigger
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AcquisitionTrigger.subclass:
            return AcquisitionTrigger.subclass(*args_, **kwargs_)
        else:
            return AcquisitionTrigger(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TriggerDelay(self): return self.TriggerDelay
    def set_TriggerDelay(self, TriggerDelay): self.TriggerDelay = TriggerDelay
    def get_TriggerOnEnter(self): return self.TriggerOnEnter
    def set_TriggerOnEnter(self, TriggerOnEnter): self.TriggerOnEnter = TriggerOnEnter
    def get_TriggerOnExit(self): return self.TriggerOnExit
    def set_TriggerOnExit(self, TriggerOnExit): self.TriggerOnExit = TriggerOnExit
    def get_SingleTrigger(self): return self.SingleTrigger
    def set_SingleTrigger(self, SingleTrigger): self.SingleTrigger = SingleTrigger
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.TriggerDelay is not None or
            self.TriggerOnEnter is not None or
            self.TriggerOnExit is not None or
            self.SingleTrigger is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AcquisitionTrigger', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcquisitionTrigger')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AcquisitionTrigger', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AcquisitionTrigger'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AcquisitionTrigger', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TriggerDelay is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTriggerDelay>%s</%sTriggerDelay>%s' % (namespace_, self.gds_format_double(self.TriggerDelay, input_name='TriggerDelay'), namespace_, eol_))
        if self.TriggerOnEnter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTriggerOnEnter>%s</%sTriggerOnEnter>%s' % (namespace_, self.gds_format_boolean(self.TriggerOnEnter, input_name='TriggerOnEnter'), namespace_, eol_))
        if self.TriggerOnExit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTriggerOnExit>%s</%sTriggerOnExit>%s' % (namespace_, self.gds_format_boolean(self.TriggerOnExit, input_name='TriggerOnExit'), namespace_, eol_))
        if self.SingleTrigger is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSingleTrigger>%s</%sSingleTrigger>%s' % (namespace_, self.gds_format_boolean(self.SingleTrigger, input_name='SingleTrigger'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TriggerDelay':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TriggerDelay')
            self.TriggerDelay = fval_
        elif nodeName_ == 'TriggerOnEnter':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'TriggerOnEnter')
            self.TriggerOnEnter = ival_
        elif nodeName_ == 'TriggerOnExit':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'TriggerOnExit')
            self.TriggerOnExit = ival_
        elif nodeName_ == 'SingleTrigger':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'SingleTrigger')
            self.SingleTrigger = ival_
# end class AcquisitionTrigger


class TrackingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TrackingEnabled=None, CapabilityRatio=None):
        self.original_tagname_ = None
        self.TrackingEnabled = TrackingEnabled
        self.CapabilityRatio = CapabilityRatio
    def factory(*args_, **kwargs_):
        if TrackingType.subclass:
            return TrackingType.subclass(*args_, **kwargs_)
        else:
            return TrackingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TrackingEnabled(self): return self.TrackingEnabled
    def set_TrackingEnabled(self, TrackingEnabled): self.TrackingEnabled = TrackingEnabled
    def get_CapabilityRatio(self): return self.CapabilityRatio
    def set_CapabilityRatio(self, CapabilityRatio): self.CapabilityRatio = CapabilityRatio
    def validate_CapabilityRatioType(self, value):
        # Validate type CapabilityRatioType, a restriction on xs:double.
        pass
    def hasContent_(self):
        if (
            self.TrackingEnabled is not None or
            self.CapabilityRatio is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TrackingType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrackingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TrackingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TrackingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TrackingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TrackingEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTrackingEnabled>%s</%sTrackingEnabled>%s' % (namespace_, self.gds_format_boolean(self.TrackingEnabled, input_name='TrackingEnabled'), namespace_, eol_))
        if self.CapabilityRatio is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCapabilityRatio>%s</%sCapabilityRatio>%s' % (namespace_, self.gds_format_double(self.CapabilityRatio, input_name='CapabilityRatio'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TrackingEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'TrackingEnabled')
            self.TrackingEnabled = ival_
        elif nodeName_ == 'CapabilityRatio':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CapabilityRatio')
            self.CapabilityRatio = fval_
            self.validate_CapabilityRatioType(self.CapabilityRatio)    # validate type CapabilityRatioType
# end class TrackingType


class TolTableType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GantryRtn=None, CollRtn=None, CouchVrt=None, CouchLat=None, CouchLng=None, CouchRtn=None, Y12=None, X12=None):
        self.original_tagname_ = None
        self.GantryRtn = GantryRtn
        self.CollRtn = CollRtn
        self.CouchVrt = CouchVrt
        self.CouchLat = CouchLat
        self.CouchLng = CouchLng
        self.CouchRtn = CouchRtn
        self.Y12 = Y12
        self.X12 = X12
    def factory(*args_, **kwargs_):
        if TolTableType.subclass:
            return TolTableType.subclass(*args_, **kwargs_)
        else:
            return TolTableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GantryRtn(self): return self.GantryRtn
    def set_GantryRtn(self, GantryRtn): self.GantryRtn = GantryRtn
    def get_CollRtn(self): return self.CollRtn
    def set_CollRtn(self, CollRtn): self.CollRtn = CollRtn
    def get_CouchVrt(self): return self.CouchVrt
    def set_CouchVrt(self, CouchVrt): self.CouchVrt = CouchVrt
    def get_CouchLat(self): return self.CouchLat
    def set_CouchLat(self, CouchLat): self.CouchLat = CouchLat
    def get_CouchLng(self): return self.CouchLng
    def set_CouchLng(self, CouchLng): self.CouchLng = CouchLng
    def get_CouchRtn(self): return self.CouchRtn
    def set_CouchRtn(self, CouchRtn): self.CouchRtn = CouchRtn
    def get_Y12(self): return self.Y12
    def set_Y12(self, Y12): self.Y12 = Y12
    def get_X12(self): return self.X12
    def set_X12(self, X12): self.X12 = X12
    def hasContent_(self):
        if (
            self.GantryRtn is not None or
            self.CollRtn is not None or
            self.CouchVrt is not None or
            self.CouchLat is not None or
            self.CouchLng is not None or
            self.CouchRtn is not None or
            self.Y12 is not None or
            self.X12 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TolTableType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TolTableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TolTableType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TolTableType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TolTableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GantryRtn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGantryRtn>%s</%sGantryRtn>%s' % (namespace_, self.gds_format_double(self.GantryRtn, input_name='GantryRtn'), namespace_, eol_))
        if self.CollRtn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCollRtn>%s</%sCollRtn>%s' % (namespace_, self.gds_format_double(self.CollRtn, input_name='CollRtn'), namespace_, eol_))
        if self.CouchVrt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCouchVrt>%s</%sCouchVrt>%s' % (namespace_, self.gds_format_double(self.CouchVrt, input_name='CouchVrt'), namespace_, eol_))
        if self.CouchLat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCouchLat>%s</%sCouchLat>%s' % (namespace_, self.gds_format_double(self.CouchLat, input_name='CouchLat'), namespace_, eol_))
        if self.CouchLng is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCouchLng>%s</%sCouchLng>%s' % (namespace_, self.gds_format_double(self.CouchLng, input_name='CouchLng'), namespace_, eol_))
        if self.CouchRtn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCouchRtn>%s</%sCouchRtn>%s' % (namespace_, self.gds_format_double(self.CouchRtn, input_name='CouchRtn'), namespace_, eol_))
        if self.Y12 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sY12>%s</%sY12>%s' % (namespace_, self.gds_format_double(self.Y12, input_name='Y12'), namespace_, eol_))
        if self.X12 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX12>%s</%sX12>%s' % (namespace_, self.gds_format_double(self.X12, input_name='X12'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GantryRtn':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'GantryRtn')
            self.GantryRtn = fval_
        elif nodeName_ == 'CollRtn':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CollRtn')
            self.CollRtn = fval_
        elif nodeName_ == 'CouchVrt':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CouchVrt')
            self.CouchVrt = fval_
        elif nodeName_ == 'CouchLat':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CouchLat')
            self.CouchLat = fval_
        elif nodeName_ == 'CouchLng':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CouchLng')
            self.CouchLng = fval_
        elif nodeName_ == 'CouchRtn':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CouchRtn')
            self.CouchRtn = fval_
        elif nodeName_ == 'Y12':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Y12')
            self.Y12 = fval_
        elif nodeName_ == 'X12':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'X12')
            self.X12 = fval_
# end class TolTableType


class VelTableType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GantryRtn=None, CollRtn=None, CouchVrt=None, CouchLat=None, CouchLng=None, CouchRtn=None, X1=None, X2=None, Y1=None, Y2=None):
        self.original_tagname_ = None
        self.GantryRtn = GantryRtn
        self.CollRtn = CollRtn
        self.CouchVrt = CouchVrt
        self.CouchLat = CouchLat
        self.CouchLng = CouchLng
        self.CouchRtn = CouchRtn
        self.X1 = X1
        self.X2 = X2
        self.Y1 = Y1
        self.Y2 = Y2
    def factory(*args_, **kwargs_):
        if VelTableType.subclass:
            return VelTableType.subclass(*args_, **kwargs_)
        else:
            return VelTableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GantryRtn(self): return self.GantryRtn
    def set_GantryRtn(self, GantryRtn): self.GantryRtn = GantryRtn
    def get_CollRtn(self): return self.CollRtn
    def set_CollRtn(self, CollRtn): self.CollRtn = CollRtn
    def get_CouchVrt(self): return self.CouchVrt
    def set_CouchVrt(self, CouchVrt): self.CouchVrt = CouchVrt
    def get_CouchLat(self): return self.CouchLat
    def set_CouchLat(self, CouchLat): self.CouchLat = CouchLat
    def get_CouchLng(self): return self.CouchLng
    def set_CouchLng(self, CouchLng): self.CouchLng = CouchLng
    def get_CouchRtn(self): return self.CouchRtn
    def set_CouchRtn(self, CouchRtn): self.CouchRtn = CouchRtn
    def get_X1(self): return self.X1
    def set_X1(self, X1): self.X1 = X1
    def get_X2(self): return self.X2
    def set_X2(self, X2): self.X2 = X2
    def get_Y1(self): return self.Y1
    def set_Y1(self, Y1): self.Y1 = Y1
    def get_Y2(self): return self.Y2
    def set_Y2(self, Y2): self.Y2 = Y2
    def hasContent_(self):
        if (
            self.GantryRtn is not None or
            self.CollRtn is not None or
            self.CouchVrt is not None or
            self.CouchLat is not None or
            self.CouchLng is not None or
            self.CouchRtn is not None or
            self.X1 is not None or
            self.X2 is not None or
            self.Y1 is not None or
            self.Y2 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VelTableType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VelTableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VelTableType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VelTableType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VelTableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GantryRtn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGantryRtn>%s</%sGantryRtn>%s' % (namespace_, self.gds_format_double(self.GantryRtn, input_name='GantryRtn'), namespace_, eol_))
        if self.CollRtn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCollRtn>%s</%sCollRtn>%s' % (namespace_, self.gds_format_double(self.CollRtn, input_name='CollRtn'), namespace_, eol_))
        if self.CouchVrt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCouchVrt>%s</%sCouchVrt>%s' % (namespace_, self.gds_format_double(self.CouchVrt, input_name='CouchVrt'), namespace_, eol_))
        if self.CouchLat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCouchLat>%s</%sCouchLat>%s' % (namespace_, self.gds_format_double(self.CouchLat, input_name='CouchLat'), namespace_, eol_))
        if self.CouchLng is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCouchLng>%s</%sCouchLng>%s' % (namespace_, self.gds_format_double(self.CouchLng, input_name='CouchLng'), namespace_, eol_))
        if self.CouchRtn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCouchRtn>%s</%sCouchRtn>%s' % (namespace_, self.gds_format_double(self.CouchRtn, input_name='CouchRtn'), namespace_, eol_))
        if self.X1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX1>%s</%sX1>%s' % (namespace_, self.gds_format_double(self.X1, input_name='X1'), namespace_, eol_))
        if self.X2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX2>%s</%sX2>%s' % (namespace_, self.gds_format_double(self.X2, input_name='X2'), namespace_, eol_))
        if self.Y1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sY1>%s</%sY1>%s' % (namespace_, self.gds_format_double(self.Y1, input_name='Y1'), namespace_, eol_))
        if self.Y2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sY2>%s</%sY2>%s' % (namespace_, self.gds_format_double(self.Y2, input_name='Y2'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GantryRtn':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'GantryRtn')
            self.GantryRtn = fval_
        elif nodeName_ == 'CollRtn':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CollRtn')
            self.CollRtn = fval_
        elif nodeName_ == 'CouchVrt':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CouchVrt')
            self.CouchVrt = fval_
        elif nodeName_ == 'CouchLat':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CouchLat')
            self.CouchLat = fval_
        elif nodeName_ == 'CouchLng':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CouchLng')
            self.CouchLng = fval_
        elif nodeName_ == 'CouchRtn':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CouchRtn')
            self.CouchRtn = fval_
        elif nodeName_ == 'X1':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'X1')
            self.X1 = fval_
        elif nodeName_ == 'X2':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'X2')
            self.X2 = fval_
        elif nodeName_ == 'Y1':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Y1')
            self.Y1 = fval_
        elif nodeName_ == 'Y2':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Y2')
            self.Y2 = fval_
# end class VelTableType


class AccsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Acc1=None, Acc2=None, Acc3=None, Acc4=None):
        self.original_tagname_ = None
        self.Acc1 = Acc1
        self.Acc2 = Acc2
        self.Acc3 = Acc3
        self.Acc4 = Acc4
    def factory(*args_, **kwargs_):
        if AccsType.subclass:
            return AccsType.subclass(*args_, **kwargs_)
        else:
            return AccsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Acc1(self): return self.Acc1
    def set_Acc1(self, Acc1): self.Acc1 = Acc1
    def get_Acc2(self): return self.Acc2
    def set_Acc2(self, Acc2): self.Acc2 = Acc2
    def get_Acc3(self): return self.Acc3
    def set_Acc3(self, Acc3): self.Acc3 = Acc3
    def get_Acc4(self): return self.Acc4
    def set_Acc4(self, Acc4): self.Acc4 = Acc4
    def hasContent_(self):
        if (
            self.Acc1 is not None or
            self.Acc2 is not None or
            self.Acc3 is not None or
            self.Acc4 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AccsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Acc1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAcc1>%s</%sAcc1>%s' % (namespace_, self.gds_format_integer(self.Acc1, input_name='Acc1'), namespace_, eol_))
        if self.Acc2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAcc2>%s</%sAcc2>%s' % (namespace_, self.gds_format_integer(self.Acc2, input_name='Acc2'), namespace_, eol_))
        if self.Acc3 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAcc3>%s</%sAcc3>%s' % (namespace_, self.gds_format_integer(self.Acc3, input_name='Acc3'), namespace_, eol_))
        if self.Acc4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAcc4>%s</%sAcc4>%s' % (namespace_, self.gds_format_integer(self.Acc4, input_name='Acc4'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Acc1':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Acc1')
            self.Acc1 = ival_
        elif nodeName_ == 'Acc2':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Acc2')
            self.Acc2 = ival_
        elif nodeName_ == 'Acc3':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Acc3')
            self.Acc3 = ival_
        elif nodeName_ == 'Acc4':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Acc4')
            self.Acc4 = ival_
# end class AccsType


class ControlPointsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cp=None):
        self.original_tagname_ = None
        if Cp is None:
            self.Cp = []
        else:
            self.Cp = Cp
    def factory(*args_, **kwargs_):
        if ControlPointsType.subclass:
            return ControlPointsType.subclass(*args_, **kwargs_)
        else:
            return ControlPointsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cp(self): return self.Cp
    def set_Cp(self, Cp): self.Cp = Cp
    def add_Cp(self, value): self.Cp.append(value)
    def insert_Cp_at(self, index, value): self.Cp.insert(index, value)
    def replace_Cp_at(self, index, value): self.Cp[index] = value
    def hasContent_(self):
        if (
            self.Cp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ControlPointsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ControlPointsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ControlPointsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ControlPointsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ControlPointsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Cp_ in self.Cp:
            Cp_.export(outfile, level, namespace_, name_='Cp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cp':
            obj_ = CpType.factory()
            obj_.build(child_)
            self.Cp.append(obj_)
            obj_.original_tagname_ = 'Cp'
# end class ControlPointsType


class CpType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TreatProgressEvent=None, SubBeam=None, Energy=None, Mu=None, DRate=None, GantryRtn=None, CollRtn=None, CouchVrt=None, CouchLat=None, CouchLng=None, CouchRtn=None, Y1=None, Y2=None, X1=None, X2=None, Mlc=None):
        self.original_tagname_ = None
        self.TreatProgressEvent = TreatProgressEvent
        self.SubBeam = SubBeam
        self.Energy = Energy
        self.Mu = Mu
        self.DRate = DRate
        self.GantryRtn = GantryRtn
        self.CollRtn = CollRtn
        self.CouchVrt = CouchVrt
        self.CouchLat = CouchLat
        self.CouchLng = CouchLng
        self.CouchRtn = CouchRtn
        self.Y1 = Y1
        self.Y2 = Y2
        self.X1 = X1
        self.X2 = X2
        if Mlc is None:
            self.Mlc = []
        else:
            self.Mlc = Mlc
    def factory(*args_, **kwargs_):
        if CpType.subclass:
            return CpType.subclass(*args_, **kwargs_)
        else:
            return CpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TreatProgressEvent(self): return self.TreatProgressEvent
    def set_TreatProgressEvent(self, TreatProgressEvent): self.TreatProgressEvent = TreatProgressEvent
    def get_SubBeam(self): return self.SubBeam
    def set_SubBeam(self, SubBeam): self.SubBeam = SubBeam
    def get_Energy(self): return self.Energy
    def set_Energy(self, Energy): self.Energy = Energy
    def get_Mu(self): return self.Mu
    def set_Mu(self, Mu): self.Mu = Mu
    def get_DRate(self): return self.DRate
    def set_DRate(self, DRate): self.DRate = DRate
    def get_GantryRtn(self): return self.GantryRtn
    def set_GantryRtn(self, GantryRtn): self.GantryRtn = GantryRtn
    def get_CollRtn(self): return self.CollRtn
    def set_CollRtn(self, CollRtn): self.CollRtn = CollRtn
    def get_CouchVrt(self): return self.CouchVrt
    def set_CouchVrt(self, CouchVrt): self.CouchVrt = CouchVrt
    def get_CouchLat(self): return self.CouchLat
    def set_CouchLat(self, CouchLat): self.CouchLat = CouchLat
    def get_CouchLng(self): return self.CouchLng
    def set_CouchLng(self, CouchLng): self.CouchLng = CouchLng
    def get_CouchRtn(self): return self.CouchRtn
    def set_CouchRtn(self, CouchRtn): self.CouchRtn = CouchRtn
    def get_Y1(self): return self.Y1
    def set_Y1(self, Y1): self.Y1 = Y1
    def get_Y2(self): return self.Y2
    def set_Y2(self, Y2): self.Y2 = Y2
    def get_X1(self): return self.X1
    def set_X1(self, X1): self.X1 = X1
    def get_X2(self): return self.X2
    def set_X2(self, X2): self.X2 = X2
    def get_Mlc(self): return self.Mlc
    def set_Mlc(self, Mlc): self.Mlc = Mlc
    def add_Mlc(self, value): self.Mlc.append(value)
    def insert_Mlc_at(self, index, value): self.Mlc.insert(index, value)
    def replace_Mlc_at(self, index, value): self.Mlc[index] = value
    def validate_MuType(self, value):
        # Validate type MuType, a restriction on xs:double.
        pass
    def validate_DRateType(self, value):
        # Validate type DRateType, a restriction on xs:double.
        pass
    def hasContent_(self):
        if (
            self.TreatProgressEvent is not None or
            self.SubBeam is not None or
            self.Energy is not None or
            self.Mu is not None or
            self.DRate is not None or
            self.GantryRtn is not None or
            self.CollRtn is not None or
            self.CouchVrt is not None or
            self.CouchLat is not None or
            self.CouchLng is not None or
            self.CouchRtn is not None or
            self.Y1 is not None or
            self.Y2 is not None or
            self.X1 is not None or
            self.X2 is not None or
            self.Mlc
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CpType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CpType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CpType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TreatProgressEvent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTreatProgressEvent>%s</%sTreatProgressEvent>%s' % (namespace_, self.gds_format_string(quote_xml(self.TreatProgressEvent).encode(ExternalEncoding), input_name='TreatProgressEvent'), namespace_, eol_))
        if self.SubBeam is not None:
            self.SubBeam.export(outfile, level, namespace_, name_='SubBeam', pretty_print=pretty_print)
        if self.Energy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnergy>%s</%sEnergy>%s' % (namespace_, self.gds_format_string(quote_xml(self.Energy).encode(ExternalEncoding), input_name='Energy'), namespace_, eol_))
        if self.Mu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMu>%s</%sMu>%s' % (namespace_, self.gds_format_double(self.Mu, input_name='Mu'), namespace_, eol_))
        if self.DRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDRate>%s</%sDRate>%s' % (namespace_, self.gds_format_double(self.DRate, input_name='DRate'), namespace_, eol_))
        if self.GantryRtn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGantryRtn>%s</%sGantryRtn>%s' % (namespace_, self.gds_format_double(self.GantryRtn, input_name='GantryRtn'), namespace_, eol_))
        if self.CollRtn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCollRtn>%s</%sCollRtn>%s' % (namespace_, self.gds_format_double(self.CollRtn, input_name='CollRtn'), namespace_, eol_))
        if self.CouchVrt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCouchVrt>%s</%sCouchVrt>%s' % (namespace_, self.gds_format_double(self.CouchVrt, input_name='CouchVrt'), namespace_, eol_))
        if self.CouchLat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCouchLat>%s</%sCouchLat>%s' % (namespace_, self.gds_format_double(self.CouchLat, input_name='CouchLat'), namespace_, eol_))
        if self.CouchLng is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCouchLng>%s</%sCouchLng>%s' % (namespace_, self.gds_format_double(self.CouchLng, input_name='CouchLng'), namespace_, eol_))
        if self.CouchRtn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCouchRtn>%s</%sCouchRtn>%s' % (namespace_, self.gds_format_double(self.CouchRtn, input_name='CouchRtn'), namespace_, eol_))
        if self.Y1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sY1>%s</%sY1>%s' % (namespace_, self.gds_format_double(self.Y1, input_name='Y1'), namespace_, eol_))
        if self.Y2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sY2>%s</%sY2>%s' % (namespace_, self.gds_format_double(self.Y2, input_name='Y2'), namespace_, eol_))
        if self.X1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX1>%s</%sX1>%s' % (namespace_, self.gds_format_double(self.X1, input_name='X1'), namespace_, eol_))
        if self.X2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX2>%s</%sX2>%s' % (namespace_, self.gds_format_double(self.X2, input_name='X2'), namespace_, eol_))
        for Mlc_ in self.Mlc:
            Mlc_.export(outfile, level, namespace_, name_='Mlc', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TreatProgressEvent':
            TreatProgressEvent_ = child_.text
            TreatProgressEvent_ = self.gds_validate_string(TreatProgressEvent_, node, 'TreatProgressEvent')
            self.TreatProgressEvent = TreatProgressEvent_
        elif nodeName_ == 'SubBeam':
            obj_ = SubBeamType.factory()
            obj_.build(child_)
            self.SubBeam = obj_
            obj_.original_tagname_ = 'SubBeam'
        elif nodeName_ == 'Energy':
            Energy_ = child_.text
            Energy_ = self.gds_validate_string(Energy_, node, 'Energy')
            self.Energy = Energy_
        elif nodeName_ == 'Mu':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Mu')
            self.Mu = fval_
            self.validate_MuType(self.Mu)    # validate type MuType
        elif nodeName_ == 'DRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DRate')
            self.DRate = fval_
            self.validate_DRateType(self.DRate)    # validate type DRateType
        elif nodeName_ == 'GantryRtn':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'GantryRtn')
            self.GantryRtn = fval_
        elif nodeName_ == 'CollRtn':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CollRtn')
            self.CollRtn = fval_
        elif nodeName_ == 'CouchVrt':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CouchVrt')
            self.CouchVrt = fval_
        elif nodeName_ == 'CouchLat':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CouchLat')
            self.CouchLat = fval_
        elif nodeName_ == 'CouchLng':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CouchLng')
            self.CouchLng = fval_
        elif nodeName_ == 'CouchRtn':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CouchRtn')
            self.CouchRtn = fval_
        elif nodeName_ == 'Y1':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Y1')
            self.Y1 = fval_
        elif nodeName_ == 'Y2':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Y2')
            self.Y2 = fval_
        elif nodeName_ == 'X1':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'X1')
            self.X1 = fval_
        elif nodeName_ == 'X2':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'X2')
            self.X2 = fval_
        elif nodeName_ == 'Mlc':
            obj_ = MlcType.factory()
            obj_.build(child_)
            self.Mlc.append(obj_)
            obj_.original_tagname_ = 'Mlc'
# end class CpType


class SubBeamType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Seq=None, SubbeamGUID=None, Name=None, MaxRadTime=None, TrackingTrainingOnly=None):
        self.original_tagname_ = None
        self.Seq = Seq
        self.SubbeamGUID = SubbeamGUID
        self.Name = Name
        self.MaxRadTime = MaxRadTime
        self.TrackingTrainingOnly = TrackingTrainingOnly
    def factory(*args_, **kwargs_):
        if SubBeamType.subclass:
            return SubBeamType.subclass(*args_, **kwargs_)
        else:
            return SubBeamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Seq(self): return self.Seq
    def set_Seq(self, Seq): self.Seq = Seq
    def get_SubbeamGUID(self): return self.SubbeamGUID
    def set_SubbeamGUID(self, SubbeamGUID): self.SubbeamGUID = SubbeamGUID
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_MaxRadTime(self): return self.MaxRadTime
    def set_MaxRadTime(self, MaxRadTime): self.MaxRadTime = MaxRadTime
    def get_TrackingTrainingOnly(self): return self.TrackingTrainingOnly
    def set_TrackingTrainingOnly(self, TrackingTrainingOnly): self.TrackingTrainingOnly = TrackingTrainingOnly
    def hasContent_(self):
        if (
            self.Seq is not None or
            self.SubbeamGUID is not None or
            self.Name is not None or
            self.MaxRadTime is not None or
            self.TrackingTrainingOnly is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubBeamType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubBeamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubBeamType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubBeamType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SubBeamType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Seq is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSeq>%s</%sSeq>%s' % (namespace_, self.gds_format_integer(self.Seq, input_name='Seq'), namespace_, eol_))
        if self.SubbeamGUID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubbeamGUID>%s</%sSubbeamGUID>%s' % (namespace_, self.gds_format_string(quote_xml(self.SubbeamGUID).encode(ExternalEncoding), input_name='SubbeamGUID'), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.MaxRadTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxRadTime>%s</%sMaxRadTime>%s' % (namespace_, self.gds_format_double(self.MaxRadTime, input_name='MaxRadTime'), namespace_, eol_))
        if self.TrackingTrainingOnly is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTrackingTrainingOnly>%s</%sTrackingTrainingOnly>%s' % (namespace_, self.gds_format_boolean(self.TrackingTrainingOnly, input_name='TrackingTrainingOnly'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Seq':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Seq')
            self.Seq = ival_
        elif nodeName_ == 'SubbeamGUID':
            SubbeamGUID_ = child_.text
            SubbeamGUID_ = self.gds_validate_string(SubbeamGUID_, node, 'SubbeamGUID')
            self.SubbeamGUID = SubbeamGUID_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'MaxRadTime':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MaxRadTime')
            self.MaxRadTime = fval_
        elif nodeName_ == 'TrackingTrainingOnly':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'TrackingTrainingOnly')
            self.TrackingTrainingOnly = ival_
# end class SubBeamType


class MlcType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, B=None, A=None):
        self.original_tagname_ = None
        self.ID = ID
        self.B = B
        self.A = A
    def factory(*args_, **kwargs_):
        if MlcType.subclass:
            return MlcType.subclass(*args_, **kwargs_)
        else:
            return MlcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_B(self): return self.B
    def set_B(self, B): self.B = B
    def get_A(self): return self.A
    def set_A(self, A): self.A = A
    def hasContent_(self):
        if (
            self.ID is not None or
            self.B is not None or
            self.A is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MlcType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MlcType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MlcType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MlcType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MlcType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_integer(self.ID, input_name='ID'), namespace_, eol_))
        if self.B is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sB>%s</%sB>%s' % (namespace_, self.gds_format_string(quote_xml(self.B).encode(ExternalEncoding), input_name='B'), namespace_, eol_))
        if self.A is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sA>%s</%sA>%s' % (namespace_, self.gds_format_string(quote_xml(self.A).encode(ExternalEncoding), input_name='A'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'B':
            B_ = child_.text
            B_ = self.gds_validate_string(B_, node, 'B')
            self.B = B_
        elif nodeName_ == 'A':
            A_ = child_.text
            A_ = self.gds_validate_string(A_, node, 'A')
            self.A = A_
# end class MlcType


class ImagingParametersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DuringTreatment=None, OutsideTreatment=None, CustomTargetPermission=None, ImagingVelTable=None, LatchBEL=True, LatchKVBEL=True, ImagingPoints=None, ImagingTolerances=None, GatingParameters=None):
        self.original_tagname_ = None
        self.DuringTreatment = DuringTreatment
        self.OutsideTreatment = OutsideTreatment
        self.CustomTargetPermission = CustomTargetPermission
        self.ImagingVelTable = ImagingVelTable
        self.LatchBEL = LatchBEL
        self.LatchKVBEL = LatchKVBEL
        self.ImagingPoints = ImagingPoints
        self.ImagingTolerances = ImagingTolerances
        self.GatingParameters = GatingParameters
    def factory(*args_, **kwargs_):
        if ImagingParametersType.subclass:
            return ImagingParametersType.subclass(*args_, **kwargs_)
        else:
            return ImagingParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DuringTreatment(self): return self.DuringTreatment
    def set_DuringTreatment(self, DuringTreatment): self.DuringTreatment = DuringTreatment
    def get_OutsideTreatment(self): return self.OutsideTreatment
    def set_OutsideTreatment(self, OutsideTreatment): self.OutsideTreatment = OutsideTreatment
    def get_CustomTargetPermission(self): return self.CustomTargetPermission
    def set_CustomTargetPermission(self, CustomTargetPermission): self.CustomTargetPermission = CustomTargetPermission
    def get_ImagingVelTable(self): return self.ImagingVelTable
    def set_ImagingVelTable(self, ImagingVelTable): self.ImagingVelTable = ImagingVelTable
    def get_LatchBEL(self): return self.LatchBEL
    def set_LatchBEL(self, LatchBEL): self.LatchBEL = LatchBEL
    def get_LatchKVBEL(self): return self.LatchKVBEL
    def set_LatchKVBEL(self, LatchKVBEL): self.LatchKVBEL = LatchKVBEL
    def get_ImagingPoints(self): return self.ImagingPoints
    def set_ImagingPoints(self, ImagingPoints): self.ImagingPoints = ImagingPoints
    def get_ImagingTolerances(self): return self.ImagingTolerances
    def set_ImagingTolerances(self, ImagingTolerances): self.ImagingTolerances = ImagingTolerances
    def get_GatingParameters(self): return self.GatingParameters
    def set_GatingParameters(self, GatingParameters): self.GatingParameters = GatingParameters
    def hasContent_(self):
        if (
            self.DuringTreatment is not None or
            self.OutsideTreatment is not None or
            self.CustomTargetPermission is not None or
            self.ImagingVelTable is not None or
            self.LatchBEL is not None or
            self.LatchKVBEL is not None or
            self.ImagingPoints is not None or
            self.ImagingTolerances is not None or
            self.GatingParameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ImagingParametersType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImagingParametersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ImagingParametersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ImagingParametersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ImagingParametersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DuringTreatment is not None:
            self.DuringTreatment.export(outfile, level, namespace_, name_='DuringTreatment', pretty_print=pretty_print)
        if self.OutsideTreatment is not None:
            self.OutsideTreatment.export(outfile, level, namespace_, name_='OutsideTreatment', pretty_print=pretty_print)
        if self.CustomTargetPermission is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustomTargetPermission>%s</%sCustomTargetPermission>%s' % (namespace_, self.gds_format_boolean(self.CustomTargetPermission, input_name='CustomTargetPermission'), namespace_, eol_))
        if self.ImagingVelTable is not None:
            self.ImagingVelTable.export(outfile, level, namespace_, name_='ImagingVelTable', pretty_print=pretty_print)
        if self.LatchBEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLatchBEL>%s</%sLatchBEL>%s' % (namespace_, self.gds_format_boolean(self.LatchBEL, input_name='LatchBEL'), namespace_, eol_))
        if self.LatchKVBEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLatchKVBEL>%s</%sLatchKVBEL>%s' % (namespace_, self.gds_format_boolean(self.LatchKVBEL, input_name='LatchKVBEL'), namespace_, eol_))
        if self.ImagingPoints is not None:
            self.ImagingPoints.export(outfile, level, namespace_, name_='ImagingPoints', pretty_print=pretty_print)
        if self.ImagingTolerances is not None:
            self.ImagingTolerances.export(outfile, level, namespace_, name_='ImagingTolerances', pretty_print=pretty_print)
        if self.GatingParameters is not None:
            self.GatingParameters.export(outfile, level, namespace_, name_='GatingParameters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DuringTreatment':
            obj_ = DuringTreatmentType.factory()
            obj_.build(child_)
            self.DuringTreatment = obj_
            obj_.original_tagname_ = 'DuringTreatment'
        elif nodeName_ == 'OutsideTreatment':
            obj_ = OutsideTreatmentType.factory()
            obj_.build(child_)
            self.OutsideTreatment = obj_
            obj_.original_tagname_ = 'OutsideTreatment'
        elif nodeName_ == 'CustomTargetPermission':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'CustomTargetPermission')
            self.CustomTargetPermission = ival_
        elif nodeName_ == 'ImagingVelTable':
            obj_ = ImagingVelTableType.factory()
            obj_.build(child_)
            self.ImagingVelTable = obj_
            obj_.original_tagname_ = 'ImagingVelTable'
        elif nodeName_ == 'LatchBEL':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'LatchBEL')
            self.LatchBEL = ival_
        elif nodeName_ == 'LatchKVBEL':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'LatchKVBEL')
            self.LatchKVBEL = ival_
        elif nodeName_ == 'ImagingPoints':
            obj_ = ImagingPointsType.factory()
            obj_.build(child_)
            self.ImagingPoints = obj_
            obj_.original_tagname_ = 'ImagingPoints'
        elif nodeName_ == 'ImagingTolerances':
            obj_ = ImagingTolerancesType.factory()
            obj_.build(child_)
            self.ImagingTolerances = obj_
            obj_.original_tagname_ = 'ImagingTolerances'
        elif nodeName_ == 'GatingParameters':
            obj_ = GatingParametersType.factory()
            obj_.build(child_)
            self.GatingParameters = obj_
            obj_.original_tagname_ = 'GatingParameters'
# end class ImagingParametersType


class DuringTreatmentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if DuringTreatmentType.subclass:
            return DuringTreatmentType.subclass(*args_, **kwargs_)
        else:
            return DuringTreatmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DuringTreatmentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DuringTreatmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DuringTreatmentType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DuringTreatmentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DuringTreatmentType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DuringTreatmentType


class OutsideTreatmentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MaxMu=None):
        self.original_tagname_ = None
        self.MaxMu = MaxMu
    def factory(*args_, **kwargs_):
        if OutsideTreatmentType.subclass:
            return OutsideTreatmentType.subclass(*args_, **kwargs_)
        else:
            return OutsideTreatmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MaxMu(self): return self.MaxMu
    def set_MaxMu(self, MaxMu): self.MaxMu = MaxMu
    def hasContent_(self):
        if (
            self.MaxMu is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OutsideTreatmentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OutsideTreatmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OutsideTreatmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OutsideTreatmentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OutsideTreatmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MaxMu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxMu>%s</%sMaxMu>%s' % (namespace_, self.gds_format_double(self.MaxMu, input_name='MaxMu'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MaxMu':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MaxMu')
            self.MaxMu = fval_
# end class OutsideTreatmentType


class ImagingVelTableType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GantryRtn=None, CollRtn=None, CouchVrt=None, CouchLat=None, CouchLng=None, CouchRtn=None, X1=None, X2=None, Y1=None, Y2=None):
        self.original_tagname_ = None
        self.GantryRtn = GantryRtn
        self.CollRtn = CollRtn
        self.CouchVrt = CouchVrt
        self.CouchLat = CouchLat
        self.CouchLng = CouchLng
        self.CouchRtn = CouchRtn
        self.X1 = X1
        self.X2 = X2
        self.Y1 = Y1
        self.Y2 = Y2
    def factory(*args_, **kwargs_):
        if ImagingVelTableType.subclass:
            return ImagingVelTableType.subclass(*args_, **kwargs_)
        else:
            return ImagingVelTableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GantryRtn(self): return self.GantryRtn
    def set_GantryRtn(self, GantryRtn): self.GantryRtn = GantryRtn
    def get_CollRtn(self): return self.CollRtn
    def set_CollRtn(self, CollRtn): self.CollRtn = CollRtn
    def get_CouchVrt(self): return self.CouchVrt
    def set_CouchVrt(self, CouchVrt): self.CouchVrt = CouchVrt
    def get_CouchLat(self): return self.CouchLat
    def set_CouchLat(self, CouchLat): self.CouchLat = CouchLat
    def get_CouchLng(self): return self.CouchLng
    def set_CouchLng(self, CouchLng): self.CouchLng = CouchLng
    def get_CouchRtn(self): return self.CouchRtn
    def set_CouchRtn(self, CouchRtn): self.CouchRtn = CouchRtn
    def get_X1(self): return self.X1
    def set_X1(self, X1): self.X1 = X1
    def get_X2(self): return self.X2
    def set_X2(self, X2): self.X2 = X2
    def get_Y1(self): return self.Y1
    def set_Y1(self, Y1): self.Y1 = Y1
    def get_Y2(self): return self.Y2
    def set_Y2(self, Y2): self.Y2 = Y2
    def hasContent_(self):
        if (
            self.GantryRtn is not None or
            self.CollRtn is not None or
            self.CouchVrt is not None or
            self.CouchLat is not None or
            self.CouchLng is not None or
            self.CouchRtn is not None or
            self.X1 is not None or
            self.X2 is not None or
            self.Y1 is not None or
            self.Y2 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ImagingVelTableType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImagingVelTableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ImagingVelTableType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ImagingVelTableType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ImagingVelTableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GantryRtn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGantryRtn>%s</%sGantryRtn>%s' % (namespace_, self.gds_format_double(self.GantryRtn, input_name='GantryRtn'), namespace_, eol_))
        if self.CollRtn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCollRtn>%s</%sCollRtn>%s' % (namespace_, self.gds_format_double(self.CollRtn, input_name='CollRtn'), namespace_, eol_))
        if self.CouchVrt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCouchVrt>%s</%sCouchVrt>%s' % (namespace_, self.gds_format_double(self.CouchVrt, input_name='CouchVrt'), namespace_, eol_))
        if self.CouchLat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCouchLat>%s</%sCouchLat>%s' % (namespace_, self.gds_format_double(self.CouchLat, input_name='CouchLat'), namespace_, eol_))
        if self.CouchLng is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCouchLng>%s</%sCouchLng>%s' % (namespace_, self.gds_format_double(self.CouchLng, input_name='CouchLng'), namespace_, eol_))
        if self.CouchRtn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCouchRtn>%s</%sCouchRtn>%s' % (namespace_, self.gds_format_double(self.CouchRtn, input_name='CouchRtn'), namespace_, eol_))
        if self.X1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX1>%s</%sX1>%s' % (namespace_, self.gds_format_double(self.X1, input_name='X1'), namespace_, eol_))
        if self.X2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX2>%s</%sX2>%s' % (namespace_, self.gds_format_double(self.X2, input_name='X2'), namespace_, eol_))
        if self.Y1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sY1>%s</%sY1>%s' % (namespace_, self.gds_format_double(self.Y1, input_name='Y1'), namespace_, eol_))
        if self.Y2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sY2>%s</%sY2>%s' % (namespace_, self.gds_format_double(self.Y2, input_name='Y2'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GantryRtn':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'GantryRtn')
            self.GantryRtn = fval_
        elif nodeName_ == 'CollRtn':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CollRtn')
            self.CollRtn = fval_
        elif nodeName_ == 'CouchVrt':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CouchVrt')
            self.CouchVrt = fval_
        elif nodeName_ == 'CouchLat':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CouchLat')
            self.CouchLat = fval_
        elif nodeName_ == 'CouchLng':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CouchLng')
            self.CouchLng = fval_
        elif nodeName_ == 'CouchRtn':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CouchRtn')
            self.CouchRtn = fval_
        elif nodeName_ == 'X1':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'X1')
            self.X1 = fval_
        elif nodeName_ == 'X2':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'X2')
            self.X2 = fval_
        elif nodeName_ == 'Y1':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Y1')
            self.Y1 = fval_
        elif nodeName_ == 'Y2':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Y2')
            self.Y2 = fval_
# end class ImagingVelTableType


class ImagingPointsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ImagingPoint=None):
        self.original_tagname_ = None
        if ImagingPoint is None:
            self.ImagingPoint = []
        else:
            self.ImagingPoint = ImagingPoint
    def factory(*args_, **kwargs_):
        if ImagingPointsType.subclass:
            return ImagingPointsType.subclass(*args_, **kwargs_)
        else:
            return ImagingPointsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ImagingPoint(self): return self.ImagingPoint
    def set_ImagingPoint(self, ImagingPoint): self.ImagingPoint = ImagingPoint
    def add_ImagingPoint(self, value): self.ImagingPoint.append(value)
    def insert_ImagingPoint_at(self, index, value): self.ImagingPoint.insert(index, value)
    def replace_ImagingPoint_at(self, index, value): self.ImagingPoint[index] = value
    def hasContent_(self):
        if (
            self.ImagingPoint
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ImagingPointsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImagingPointsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ImagingPointsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ImagingPointsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ImagingPointsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ImagingPoint_ in self.ImagingPoint:
            ImagingPoint_.export(outfile, level, namespace_, name_='ImagingPoint', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ImagingPoint':
            obj_ = ImagingPointType.factory()
            obj_.build(child_)
            self.ImagingPoint.append(obj_)
            obj_.original_tagname_ = 'ImagingPoint'
# end class ImagingPointsType


class ImagingPointType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Cp=None, Acquisition=None, AcquisitionStart=None, AcquisitionStop=None, KvFilters=None, KvBlades=None, Mvd=None, Kvd=None, Kvs=None, MvdAfter=None, KvdAfter=None, KvsAfter=None):
        self.original_tagname_ = None
        self.Cp = Cp
        if Acquisition is None:
            self.Acquisition = []
        else:
            self.Acquisition = Acquisition
        if AcquisitionStart is None:
            self.AcquisitionStart = []
        else:
            self.AcquisitionStart = AcquisitionStart
        if AcquisitionStop is None:
            self.AcquisitionStop = []
        else:
            self.AcquisitionStop = AcquisitionStop
        self.KvFilters = KvFilters
        self.KvBlades = KvBlades
        self.Mvd = Mvd
        self.Kvd = Kvd
        self.Kvs = Kvs
        self.MvdAfter = MvdAfter
        self.KvdAfter = KvdAfter
        self.KvsAfter = KvsAfter
    def factory(*args_, **kwargs_):
        if ImagingPointType.subclass:
            return ImagingPointType.subclass(*args_, **kwargs_)
        else:
            return ImagingPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cp(self): return self.Cp
    def set_Cp(self, Cp): self.Cp = Cp
    def get_Acquisition(self): return self.Acquisition
    def set_Acquisition(self, Acquisition): self.Acquisition = Acquisition
    def add_Acquisition(self, value): self.Acquisition.append(value)
    def insert_Acquisition_at(self, index, value): self.Acquisition.insert(index, value)
    def replace_Acquisition_at(self, index, value): self.Acquisition[index] = value
    def get_AcquisitionStart(self): return self.AcquisitionStart
    def set_AcquisitionStart(self, AcquisitionStart): self.AcquisitionStart = AcquisitionStart
    def add_AcquisitionStart(self, value): self.AcquisitionStart.append(value)
    def insert_AcquisitionStart_at(self, index, value): self.AcquisitionStart.insert(index, value)
    def replace_AcquisitionStart_at(self, index, value): self.AcquisitionStart[index] = value
    def get_AcquisitionStop(self): return self.AcquisitionStop
    def set_AcquisitionStop(self, AcquisitionStop): self.AcquisitionStop = AcquisitionStop
    def add_AcquisitionStop(self, value): self.AcquisitionStop.append(value)
    def insert_AcquisitionStop_at(self, index, value): self.AcquisitionStop.insert(index, value)
    def replace_AcquisitionStop_at(self, index, value): self.AcquisitionStop[index] = value
    def get_KvFilters(self): return self.KvFilters
    def set_KvFilters(self, KvFilters): self.KvFilters = KvFilters
    def get_KvBlades(self): return self.KvBlades
    def set_KvBlades(self, KvBlades): self.KvBlades = KvBlades
    def get_Mvd(self): return self.Mvd
    def set_Mvd(self, Mvd): self.Mvd = Mvd
    def get_Kvd(self): return self.Kvd
    def set_Kvd(self, Kvd): self.Kvd = Kvd
    def get_Kvs(self): return self.Kvs
    def set_Kvs(self, Kvs): self.Kvs = Kvs
    def get_MvdAfter(self): return self.MvdAfter
    def set_MvdAfter(self, MvdAfter): self.MvdAfter = MvdAfter
    def get_KvdAfter(self): return self.KvdAfter
    def set_KvdAfter(self, KvdAfter): self.KvdAfter = KvdAfter
    def get_KvsAfter(self): return self.KvsAfter
    def set_KvsAfter(self, KvsAfter): self.KvsAfter = KvsAfter
    def hasContent_(self):
        if (
            self.Cp is not None or
            self.Acquisition or
            self.AcquisitionStart or
            self.AcquisitionStop or
            self.KvFilters is not None or
            self.KvBlades is not None or
            self.Mvd is not None or
            self.Kvd is not None or
            self.Kvs is not None or
            self.MvdAfter is not None or
            self.KvdAfter is not None or
            self.KvsAfter is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ImagingPointType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImagingPointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ImagingPointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ImagingPointType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ImagingPointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCp>%s</%sCp>%s' % (namespace_, self.gds_format_double(self.Cp, input_name='Cp'), namespace_, eol_))
        for Acquisition_ in self.Acquisition:
            Acquisition_.export(outfile, level, namespace_, name_='Acquisition', pretty_print=pretty_print)
        for AcquisitionStart_ in self.AcquisitionStart:
            AcquisitionStart_.export(outfile, level, namespace_, name_='AcquisitionStart', pretty_print=pretty_print)
        for AcquisitionStop_ in self.AcquisitionStop:
            AcquisitionStop_.export(outfile, level, namespace_, name_='AcquisitionStop', pretty_print=pretty_print)
        if self.KvFilters is not None:
            self.KvFilters.export(outfile, level, namespace_, name_='KvFilters', pretty_print=pretty_print)
        if self.KvBlades is not None:
            self.KvBlades.export(outfile, level, namespace_, name_='KvBlades', pretty_print=pretty_print)
        if self.Mvd is not None:
            self.Mvd.export(outfile, level, namespace_, name_='Mvd', pretty_print=pretty_print)
        if self.Kvd is not None:
            self.Kvd.export(outfile, level, namespace_, name_='Kvd', pretty_print=pretty_print)
        if self.Kvs is not None:
            self.Kvs.export(outfile, level, namespace_, name_='Kvs', pretty_print=pretty_print)
        if self.MvdAfter is not None:
            self.MvdAfter.export(outfile, level, namespace_, name_='MvdAfter', pretty_print=pretty_print)
        if self.KvdAfter is not None:
            self.KvdAfter.export(outfile, level, namespace_, name_='KvdAfter', pretty_print=pretty_print)
        if self.KvsAfter is not None:
            self.KvsAfter.export(outfile, level, namespace_, name_='KvsAfter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cp':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Cp')
            self.Cp = fval_
        elif nodeName_ == 'Acquisition':
            obj_ = Acquisition.factory()
            obj_.build(child_)
            self.Acquisition.append(obj_)
            obj_.original_tagname_ = 'Acquisition'
        elif nodeName_ == 'AcquisitionStart':
            obj_ = Acquisition.factory()
            obj_.build(child_)
            self.AcquisitionStart.append(obj_)
            obj_.original_tagname_ = 'AcquisitionStart'
        elif nodeName_ == 'AcquisitionStop':
            obj_ = Acquisition.factory()
            obj_.build(child_)
            self.AcquisitionStop.append(obj_)
            obj_.original_tagname_ = 'AcquisitionStop'
        elif nodeName_ == 'KvFilters':
            obj_ = KvFiltersType.factory()
            obj_.build(child_)
            self.KvFilters = obj_
            obj_.original_tagname_ = 'KvFilters'
        elif nodeName_ == 'KvBlades':
            obj_ = KvBladesType.factory()
            obj_.build(child_)
            self.KvBlades = obj_
            obj_.original_tagname_ = 'KvBlades'
        elif nodeName_ == 'Mvd':
            obj_ = ArmPositionsType.factory()
            obj_.build(child_)
            self.Mvd = obj_
            obj_.original_tagname_ = 'Mvd'
        elif nodeName_ == 'Kvd':
            obj_ = ArmPositionsType.factory()
            obj_.build(child_)
            self.Kvd = obj_
            obj_.original_tagname_ = 'Kvd'
        elif nodeName_ == 'Kvs':
            obj_ = ArmPositionsType.factory()
            obj_.build(child_)
            self.Kvs = obj_
            obj_.original_tagname_ = 'Kvs'
        elif nodeName_ == 'MvdAfter':
            obj_ = ArmPositionsType.factory()
            obj_.build(child_)
            self.MvdAfter = obj_
            obj_.original_tagname_ = 'MvdAfter'
        elif nodeName_ == 'KvdAfter':
            obj_ = ArmPositionsType.factory()
            obj_.build(child_)
            self.KvdAfter = obj_
            obj_.original_tagname_ = 'KvdAfter'
        elif nodeName_ == 'KvsAfter':
            obj_ = ArmPositionsType.factory()
            obj_.build(child_)
            self.KvsAfter = obj_
            obj_.original_tagname_ = 'KvsAfter'
# end class ImagingPointType


class KvFiltersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Shape=None, Foil=None):
        self.original_tagname_ = None
        self.Shape = Shape
        self.Foil = Foil
    def factory(*args_, **kwargs_):
        if KvFiltersType.subclass:
            return KvFiltersType.subclass(*args_, **kwargs_)
        else:
            return KvFiltersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Shape(self): return self.Shape
    def set_Shape(self, Shape): self.Shape = Shape
    def get_Foil(self): return self.Foil
    def set_Foil(self, Foil): self.Foil = Foil
    def validate_KvFilterType(self, value):
        # Validate type KvFilterType, a restriction on xs:integer.
        pass
    def hasContent_(self):
        if (
            self.Shape is not None or
            self.Foil is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KvFiltersType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KvFiltersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KvFiltersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KvFiltersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KvFiltersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Shape is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sShape>%s</%sShape>%s' % (namespace_, self.gds_format_integer(self.Shape, input_name='Shape'), namespace_, eol_))
        if self.Foil is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFoil>%s</%sFoil>%s' % (namespace_, self.gds_format_integer(self.Foil, input_name='Foil'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Shape':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Shape')
            self.Shape = ival_
            self.validate_KvFilterType(self.Shape)    # validate type KvFilterType
        elif nodeName_ == 'Foil':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Foil')
            self.Foil = ival_
            self.validate_KvFilterType(self.Foil)    # validate type KvFilterType
# end class KvFiltersType


class KvBladesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tracking=None, Positions=None):
        self.original_tagname_ = None
        self.Tracking = Tracking
        self.Positions = Positions
    def factory(*args_, **kwargs_):
        if KvBladesType.subclass:
            return KvBladesType.subclass(*args_, **kwargs_)
        else:
            return KvBladesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tracking(self): return self.Tracking
    def set_Tracking(self, Tracking): self.Tracking = Tracking
    def get_Positions(self): return self.Positions
    def set_Positions(self, Positions): self.Positions = Positions
    def hasContent_(self):
        if (
            self.Tracking is not None or
            self.Positions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KvBladesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KvBladesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KvBladesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KvBladesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KvBladesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tracking is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTracking>%s</%sTracking>%s' % (namespace_, self.gds_format_boolean(self.Tracking, input_name='Tracking'), namespace_, eol_))
        if self.Positions is not None:
            self.Positions.export(outfile, level, namespace_, name_='Positions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tracking':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Tracking')
            self.Tracking = ival_
        elif nodeName_ == 'Positions':
            obj_ = PositionsType.factory()
            obj_.build(child_)
            self.Positions = obj_
            obj_.original_tagname_ = 'Positions'
# end class KvBladesType


class PositionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, KVX1=None, KVX2=None, KVY1=None, KVY2=None):
        self.original_tagname_ = None
        self.KVX1 = KVX1
        self.KVX2 = KVX2
        self.KVY1 = KVY1
        self.KVY2 = KVY2
    def factory(*args_, **kwargs_):
        if PositionsType.subclass:
            return PositionsType.subclass(*args_, **kwargs_)
        else:
            return PositionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KVX1(self): return self.KVX1
    def set_KVX1(self, KVX1): self.KVX1 = KVX1
    def get_KVX2(self): return self.KVX2
    def set_KVX2(self, KVX2): self.KVX2 = KVX2
    def get_KVY1(self): return self.KVY1
    def set_KVY1(self, KVY1): self.KVY1 = KVY1
    def get_KVY2(self): return self.KVY2
    def set_KVY2(self, KVY2): self.KVY2 = KVY2
    def validate_DoubleNone(self, value):
        # Validate type DoubleNone, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.KVX1 is not None or
            self.KVX2 is not None or
            self.KVY1 is not None or
            self.KVY2 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PositionsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PositionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PositionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PositionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PositionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.KVX1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKVX1>%s</%sKVX1>%s' % (namespace_, self.gds_format_string(quote_xml(self.KVX1).encode(ExternalEncoding), input_name='KVX1'), namespace_, eol_))
        if self.KVX2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKVX2>%s</%sKVX2>%s' % (namespace_, self.gds_format_string(quote_xml(self.KVX2).encode(ExternalEncoding), input_name='KVX2'), namespace_, eol_))
        if self.KVY1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKVY1>%s</%sKVY1>%s' % (namespace_, self.gds_format_string(quote_xml(self.KVY1).encode(ExternalEncoding), input_name='KVY1'), namespace_, eol_))
        if self.KVY2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKVY2>%s</%sKVY2>%s' % (namespace_, self.gds_format_string(quote_xml(self.KVY2).encode(ExternalEncoding), input_name='KVY2'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KVX1':
            KVX1_ = child_.text
            KVX1_ = self.gds_validate_string(KVX1_, node, 'KVX1')
            self.KVX1 = KVX1_
            self.validate_DoubleNone(self.KVX1)    # validate type DoubleNone
        elif nodeName_ == 'KVX2':
            KVX2_ = child_.text
            KVX2_ = self.gds_validate_string(KVX2_, node, 'KVX2')
            self.KVX2 = KVX2_
            self.validate_DoubleNone(self.KVX2)    # validate type DoubleNone
        elif nodeName_ == 'KVY1':
            KVY1_ = child_.text
            KVY1_ = self.gds_validate_string(KVY1_, node, 'KVY1')
            self.KVY1 = KVY1_
            self.validate_DoubleNone(self.KVY1)    # validate type DoubleNone
        elif nodeName_ == 'KVY2':
            KVY2_ = child_.text
            KVY2_ = self.gds_validate_string(KVY2_, node, 'KVY2')
            self.KVY2 = KVY2_
            self.validate_DoubleNone(self.KVY2)    # validate type DoubleNone
# end class PositionsType


class ImagingTolerancesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Mvd=None, Kvd=None, Kvs=None, KvBlades=None):
        self.original_tagname_ = None
        self.Mvd = Mvd
        self.Kvd = Kvd
        self.Kvs = Kvs
        self.KvBlades = KvBlades
    def factory(*args_, **kwargs_):
        if ImagingTolerancesType.subclass:
            return ImagingTolerancesType.subclass(*args_, **kwargs_)
        else:
            return ImagingTolerancesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Mvd(self): return self.Mvd
    def set_Mvd(self, Mvd): self.Mvd = Mvd
    def get_Kvd(self): return self.Kvd
    def set_Kvd(self, Kvd): self.Kvd = Kvd
    def get_Kvs(self): return self.Kvs
    def set_Kvs(self, Kvs): self.Kvs = Kvs
    def get_KvBlades(self): return self.KvBlades
    def set_KvBlades(self, KvBlades): self.KvBlades = KvBlades
    def hasContent_(self):
        if (
            self.Mvd is not None or
            self.Kvd is not None or
            self.Kvs is not None or
            self.KvBlades is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ImagingTolerancesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImagingTolerancesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ImagingTolerancesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ImagingTolerancesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ImagingTolerancesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Mvd is not None:
            self.Mvd.export(outfile, level, namespace_, name_='Mvd', pretty_print=pretty_print)
        if self.Kvd is not None:
            self.Kvd.export(outfile, level, namespace_, name_='Kvd', pretty_print=pretty_print)
        if self.Kvs is not None:
            self.Kvs.export(outfile, level, namespace_, name_='Kvs', pretty_print=pretty_print)
        if self.KvBlades is not None:
            self.KvBlades.export(outfile, level, namespace_, name_='KvBlades', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Mvd':
            obj_ = ArmTolerances.factory()
            obj_.build(child_)
            self.Mvd = obj_
            obj_.original_tagname_ = 'Mvd'
        elif nodeName_ == 'Kvd':
            obj_ = ArmTolerances.factory()
            obj_.build(child_)
            self.Kvd = obj_
            obj_.original_tagname_ = 'Kvd'
        elif nodeName_ == 'Kvs':
            obj_ = ArmTolerances.factory()
            obj_.build(child_)
            self.Kvs = obj_
            obj_.original_tagname_ = 'Kvs'
        elif nodeName_ == 'KvBlades':
            obj_ = KvBladesType1.factory()
            obj_.build(child_)
            self.KvBlades = obj_
            obj_.original_tagname_ = 'KvBlades'
# end class ImagingTolerancesType


class KvBladesType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, KVY1=None, KVY2=None, KVX1=None, KVX2=None):
        self.original_tagname_ = None
        self.KVY1 = KVY1
        self.KVY2 = KVY2
        self.KVX1 = KVX1
        self.KVX2 = KVX2
    def factory(*args_, **kwargs_):
        if KvBladesType1.subclass:
            return KvBladesType1.subclass(*args_, **kwargs_)
        else:
            return KvBladesType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KVY1(self): return self.KVY1
    def set_KVY1(self, KVY1): self.KVY1 = KVY1
    def get_KVY2(self): return self.KVY2
    def set_KVY2(self, KVY2): self.KVY2 = KVY2
    def get_KVX1(self): return self.KVX1
    def set_KVX1(self, KVX1): self.KVX1 = KVX1
    def get_KVX2(self): return self.KVX2
    def set_KVX2(self, KVX2): self.KVX2 = KVX2
    def hasContent_(self):
        if (
            self.KVY1 is not None or
            self.KVY2 is not None or
            self.KVX1 is not None or
            self.KVX2 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KvBladesType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KvBladesType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KvBladesType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KvBladesType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KvBladesType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.KVY1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKVY1>%s</%sKVY1>%s' % (namespace_, self.gds_format_double(self.KVY1, input_name='KVY1'), namespace_, eol_))
        if self.KVY2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKVY2>%s</%sKVY2>%s' % (namespace_, self.gds_format_double(self.KVY2, input_name='KVY2'), namespace_, eol_))
        if self.KVX1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKVX1>%s</%sKVX1>%s' % (namespace_, self.gds_format_double(self.KVX1, input_name='KVX1'), namespace_, eol_))
        if self.KVX2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKVX2>%s</%sKVX2>%s' % (namespace_, self.gds_format_double(self.KVX2, input_name='KVX2'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KVY1':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'KVY1')
            self.KVY1 = fval_
        elif nodeName_ == 'KVY2':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'KVY2')
            self.KVY2 = fval_
        elif nodeName_ == 'KVX1':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'KVX1')
            self.KVX1 = fval_
        elif nodeName_ == 'KVX2':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'KVX2')
            self.KVX2 = fval_
# end class KvBladesType1


class GatingParametersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, Filter=None, QualityThreshold=None, KVGating=None, Position=None, Orientation=None, GatingWindow=None, MVAcquisitionTrigger=None, KVAcquisitionTrigger=None):
        self.original_tagname_ = None
        self.Source = Source
        self.Filter = Filter
        self.QualityThreshold = QualityThreshold
        self.KVGating = KVGating
        self.Position = Position
        self.Orientation = Orientation
        if GatingWindow is None:
            self.GatingWindow = []
        else:
            self.GatingWindow = GatingWindow
        if MVAcquisitionTrigger is None:
            self.MVAcquisitionTrigger = []
        else:
            self.MVAcquisitionTrigger = MVAcquisitionTrigger
        if KVAcquisitionTrigger is None:
            self.KVAcquisitionTrigger = []
        else:
            self.KVAcquisitionTrigger = KVAcquisitionTrigger
    def factory(*args_, **kwargs_):
        if GatingParametersType.subclass:
            return GatingParametersType.subclass(*args_, **kwargs_)
        else:
            return GatingParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_Filter(self): return self.Filter
    def set_Filter(self, Filter): self.Filter = Filter
    def get_QualityThreshold(self): return self.QualityThreshold
    def set_QualityThreshold(self, QualityThreshold): self.QualityThreshold = QualityThreshold
    def get_KVGating(self): return self.KVGating
    def set_KVGating(self, KVGating): self.KVGating = KVGating
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def get_Orientation(self): return self.Orientation
    def set_Orientation(self, Orientation): self.Orientation = Orientation
    def get_GatingWindow(self): return self.GatingWindow
    def set_GatingWindow(self, GatingWindow): self.GatingWindow = GatingWindow
    def add_GatingWindow(self, value): self.GatingWindow.append(value)
    def insert_GatingWindow_at(self, index, value): self.GatingWindow.insert(index, value)
    def replace_GatingWindow_at(self, index, value): self.GatingWindow[index] = value
    def get_MVAcquisitionTrigger(self): return self.MVAcquisitionTrigger
    def set_MVAcquisitionTrigger(self, MVAcquisitionTrigger): self.MVAcquisitionTrigger = MVAcquisitionTrigger
    def add_MVAcquisitionTrigger(self, value): self.MVAcquisitionTrigger.append(value)
    def insert_MVAcquisitionTrigger_at(self, index, value): self.MVAcquisitionTrigger.insert(index, value)
    def replace_MVAcquisitionTrigger_at(self, index, value): self.MVAcquisitionTrigger[index] = value
    def get_KVAcquisitionTrigger(self): return self.KVAcquisitionTrigger
    def set_KVAcquisitionTrigger(self, KVAcquisitionTrigger): self.KVAcquisitionTrigger = KVAcquisitionTrigger
    def add_KVAcquisitionTrigger(self, value): self.KVAcquisitionTrigger.append(value)
    def insert_KVAcquisitionTrigger_at(self, index, value): self.KVAcquisitionTrigger.insert(index, value)
    def replace_KVAcquisitionTrigger_at(self, index, value): self.KVAcquisitionTrigger[index] = value
    def hasContent_(self):
        if (
            self.Source is not None or
            self.Filter is not None or
            self.QualityThreshold is not None or
            self.KVGating is not None or
            self.Position is not None or
            self.Orientation is not None or
            self.GatingWindow or
            self.MVAcquisitionTrigger or
            self.KVAcquisitionTrigger
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatingParametersType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatingParametersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatingParametersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatingParametersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GatingParametersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSource>%s</%sSource>%s' % (namespace_, self.gds_format_string(quote_xml(self.Source).encode(ExternalEncoding), input_name='Source'), namespace_, eol_))
        if self.Filter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFilter>%s</%sFilter>%s' % (namespace_, self.gds_format_string(quote_xml(self.Filter).encode(ExternalEncoding), input_name='Filter'), namespace_, eol_))
        if self.QualityThreshold is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQualityThreshold>%s</%sQualityThreshold>%s' % (namespace_, self.gds_format_double(self.QualityThreshold, input_name='QualityThreshold'), namespace_, eol_))
        if self.KVGating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKVGating>%s</%sKVGating>%s' % (namespace_, self.gds_format_boolean(self.KVGating, input_name='KVGating'), namespace_, eol_))
        if self.Position is not None:
            self.Position.export(outfile, level, namespace_, name_='Position', pretty_print=pretty_print)
        if self.Orientation is not None:
            self.Orientation.export(outfile, level, namespace_, name_='Orientation', pretty_print=pretty_print)
        for GatingWindow_ in self.GatingWindow:
            GatingWindow_.export(outfile, level, namespace_, name_='GatingWindow', pretty_print=pretty_print)
        for MVAcquisitionTrigger_ in self.MVAcquisitionTrigger:
            MVAcquisitionTrigger_.export(outfile, level, namespace_, name_='MVAcquisitionTrigger', pretty_print=pretty_print)
        for KVAcquisitionTrigger_ in self.KVAcquisitionTrigger:
            KVAcquisitionTrigger_.export(outfile, level, namespace_, name_='KVAcquisitionTrigger', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source = Source_
        elif nodeName_ == 'Filter':
            Filter_ = child_.text
            Filter_ = self.gds_validate_string(Filter_, node, 'Filter')
            self.Filter = Filter_
        elif nodeName_ == 'QualityThreshold':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'QualityThreshold')
            self.QualityThreshold = fval_
        elif nodeName_ == 'KVGating':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'KVGating')
            self.KVGating = ival_
        elif nodeName_ == 'Position':
            obj_ = PositionType.factory()
            obj_.build(child_)
            self.Position = obj_
            obj_.original_tagname_ = 'Position'
        elif nodeName_ == 'Orientation':
            obj_ = OrientationType.factory()
            obj_.build(child_)
            self.Orientation = obj_
            obj_.original_tagname_ = 'Orientation'
        elif nodeName_ == 'GatingWindow':
            obj_ = GatingWindowType.factory()
            obj_.build(child_)
            self.GatingWindow.append(obj_)
            obj_.original_tagname_ = 'GatingWindow'
        elif nodeName_ == 'MVAcquisitionTrigger':
            obj_ = MVAcquisitionTriggerType.factory()
            obj_.build(child_)
            self.MVAcquisitionTrigger.append(obj_)
            obj_.original_tagname_ = 'MVAcquisitionTrigger'
        elif nodeName_ == 'KVAcquisitionTrigger':
            obj_ = KVAcquisitionTriggerType.factory()
            obj_.build(child_)
            self.KVAcquisitionTrigger.append(obj_)
            obj_.original_tagname_ = 'KVAcquisitionTrigger'
# end class GatingParametersType


class PositionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, X=None, Y=None, Z=None):
        self.original_tagname_ = None
        self.X = X
        self.Y = Y
        self.Z = Z
    def factory(*args_, **kwargs_):
        if PositionType.subclass:
            return PositionType.subclass(*args_, **kwargs_)
        else:
            return PositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def get_Z(self): return self.Z
    def set_Z(self, Z): self.Z = Z
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None or
            self.Z is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PositionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PositionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PositionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PositionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PositionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX>%s</%sX>%s' % (namespace_, self.gds_format_double(self.X, input_name='X'), namespace_, eol_))
        if self.Y is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sY>%s</%sY>%s' % (namespace_, self.gds_format_double(self.Y, input_name='Y'), namespace_, eol_))
        if self.Z is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sZ>%s</%sZ>%s' % (namespace_, self.gds_format_double(self.Z, input_name='Z'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'X')
            self.X = fval_
        elif nodeName_ == 'Y':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Y')
            self.Y = fval_
        elif nodeName_ == 'Z':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Z')
            self.Z = fval_
# end class PositionType


class OrientationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Qx=None, Qy=None, Qz=None, Q0=None):
        self.original_tagname_ = None
        self.Qx = Qx
        self.Qy = Qy
        self.Qz = Qz
        self.Q0 = Q0
    def factory(*args_, **kwargs_):
        if OrientationType.subclass:
            return OrientationType.subclass(*args_, **kwargs_)
        else:
            return OrientationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Qx(self): return self.Qx
    def set_Qx(self, Qx): self.Qx = Qx
    def get_Qy(self): return self.Qy
    def set_Qy(self, Qy): self.Qy = Qy
    def get_Qz(self): return self.Qz
    def set_Qz(self, Qz): self.Qz = Qz
    def get_Q0(self): return self.Q0
    def set_Q0(self, Q0): self.Q0 = Q0
    def hasContent_(self):
        if (
            self.Qx is not None or
            self.Qy is not None or
            self.Qz is not None or
            self.Q0 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrientationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrientationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrientationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrientationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OrientationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Qx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQx>%s</%sQx>%s' % (namespace_, self.gds_format_double(self.Qx, input_name='Qx'), namespace_, eol_))
        if self.Qy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQy>%s</%sQy>%s' % (namespace_, self.gds_format_double(self.Qy, input_name='Qy'), namespace_, eol_))
        if self.Qz is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQz>%s</%sQz>%s' % (namespace_, self.gds_format_double(self.Qz, input_name='Qz'), namespace_, eol_))
        if self.Q0 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQ0>%s</%sQ0>%s' % (namespace_, self.gds_format_double(self.Q0, input_name='Q0'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Qx':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Qx')
            self.Qx = fval_
        elif nodeName_ == 'Qy':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Qy')
            self.Qy = fval_
        elif nodeName_ == 'Qz':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Qz')
            self.Qz = fval_
        elif nodeName_ == 'Q0':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Q0')
            self.Q0 = fval_
# end class OrientationType


class GatingWindowType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Axis=None, Entry=None, Exit=None, EntryDelay=None, FaultOnExit=None):
        self.original_tagname_ = None
        self.Axis = Axis
        self.Entry = Entry
        self.Exit = Exit
        self.EntryDelay = EntryDelay
        self.FaultOnExit = FaultOnExit
    def factory(*args_, **kwargs_):
        if GatingWindowType.subclass:
            return GatingWindowType.subclass(*args_, **kwargs_)
        else:
            return GatingWindowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Axis(self): return self.Axis
    def set_Axis(self, Axis): self.Axis = Axis
    def get_Entry(self): return self.Entry
    def set_Entry(self, Entry): self.Entry = Entry
    def get_Exit(self): return self.Exit
    def set_Exit(self, Exit): self.Exit = Exit
    def get_EntryDelay(self): return self.EntryDelay
    def set_EntryDelay(self, EntryDelay): self.EntryDelay = EntryDelay
    def get_FaultOnExit(self): return self.FaultOnExit
    def set_FaultOnExit(self, FaultOnExit): self.FaultOnExit = FaultOnExit
    def hasContent_(self):
        if (
            self.Axis is not None or
            self.Entry is not None or
            self.Exit is not None or
            self.EntryDelay is not None or
            self.FaultOnExit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatingWindowType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatingWindowType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatingWindowType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatingWindowType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GatingWindowType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Axis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAxis>%s</%sAxis>%s' % (namespace_, self.gds_format_string(quote_xml(self.Axis).encode(ExternalEncoding), input_name='Axis'), namespace_, eol_))
        if self.Entry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEntry>%s</%sEntry>%s' % (namespace_, self.gds_format_double(self.Entry, input_name='Entry'), namespace_, eol_))
        if self.Exit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExit>%s</%sExit>%s' % (namespace_, self.gds_format_double(self.Exit, input_name='Exit'), namespace_, eol_))
        if self.EntryDelay is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEntryDelay>%s</%sEntryDelay>%s' % (namespace_, self.gds_format_double(self.EntryDelay, input_name='EntryDelay'), namespace_, eol_))
        if self.FaultOnExit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFaultOnExit>%s</%sFaultOnExit>%s' % (namespace_, self.gds_format_boolean(self.FaultOnExit, input_name='FaultOnExit'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Axis':
            Axis_ = child_.text
            Axis_ = self.gds_validate_string(Axis_, node, 'Axis')
            self.Axis = Axis_
        elif nodeName_ == 'Entry':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Entry')
            self.Entry = fval_
        elif nodeName_ == 'Exit':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Exit')
            self.Exit = fval_
        elif nodeName_ == 'EntryDelay':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'EntryDelay')
            self.EntryDelay = fval_
        elif nodeName_ == 'FaultOnExit':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'FaultOnExit')
            self.FaultOnExit = ival_
# end class GatingWindowType


class MVAcquisitionTriggerType(AcquisitionTrigger):
    subclass = None
    superclass = AcquisitionTrigger
    def __init__(self, TriggerDelay=None, TriggerOnEnter=None, TriggerOnExit=None, SingleTrigger=None):
        self.original_tagname_ = None
        super(MVAcquisitionTriggerType, self).__init__(TriggerDelay, TriggerOnEnter, TriggerOnExit, SingleTrigger, )
    def factory(*args_, **kwargs_):
        if MVAcquisitionTriggerType.subclass:
            return MVAcquisitionTriggerType.subclass(*args_, **kwargs_)
        else:
            return MVAcquisitionTriggerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(MVAcquisitionTriggerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MVAcquisitionTriggerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MVAcquisitionTriggerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MVAcquisitionTriggerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MVAcquisitionTriggerType'):
        super(MVAcquisitionTriggerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MVAcquisitionTriggerType')
    def exportChildren(self, outfile, level, namespace_='', name_='MVAcquisitionTriggerType', fromsubclass_=False, pretty_print=True):
        super(MVAcquisitionTriggerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MVAcquisitionTriggerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(MVAcquisitionTriggerType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MVAcquisitionTriggerType


class KVAcquisitionTriggerType(AcquisitionTrigger):
    subclass = None
    superclass = AcquisitionTrigger
    def __init__(self, TriggerDelay=None, TriggerOnEnter=None, TriggerOnExit=None, SingleTrigger=None):
        self.original_tagname_ = None
        super(KVAcquisitionTriggerType, self).__init__(TriggerDelay, TriggerOnEnter, TriggerOnExit, SingleTrigger, )
    def factory(*args_, **kwargs_):
        if KVAcquisitionTriggerType.subclass:
            return KVAcquisitionTriggerType.subclass(*args_, **kwargs_)
        else:
            return KVAcquisitionTriggerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(KVAcquisitionTriggerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KVAcquisitionTriggerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KVAcquisitionTriggerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KVAcquisitionTriggerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KVAcquisitionTriggerType'):
        super(KVAcquisitionTriggerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='KVAcquisitionTriggerType')
    def exportChildren(self, outfile, level, namespace_='', name_='KVAcquisitionTriggerType', fromsubclass_=False, pretty_print=True):
        super(KVAcquisitionTriggerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(KVAcquisitionTriggerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(KVAcquisitionTriggerType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class KVAcquisitionTriggerType


class BeamHoldDevicesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Dev=None):
        self.original_tagname_ = None
        self.Dev = Dev
    def factory(*args_, **kwargs_):
        if BeamHoldDevicesType.subclass:
            return BeamHoldDevicesType.subclass(*args_, **kwargs_)
        else:
            return BeamHoldDevicesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Dev(self): return self.Dev
    def set_Dev(self, Dev): self.Dev = Dev
    def hasContent_(self):
        if (
            self.Dev is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BeamHoldDevicesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BeamHoldDevicesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BeamHoldDevicesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BeamHoldDevicesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BeamHoldDevicesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Dev is not None:
            self.Dev.export(outfile, level, namespace_, name_='Dev', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Dev':
            obj_ = DevType.factory()
            obj_.build(child_)
            self.Dev = obj_
            obj_.original_tagname_ = 'Dev'
# end class BeamHoldDevicesType


class DevType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None):
        self.original_tagname_ = None
        self.Id = _cast(int, Id)
    def factory(*args_, **kwargs_):
        if DevType.subclass:
            return DevType.subclass(*args_, **kwargs_)
        else:
            return DevType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DevType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DevType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DevType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DevType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id="%s"' % self.gds_format_integer(self.Id, input_name='Id'))
    def exportChildren(self, outfile, level, namespace_='', name_='DevType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            try:
                self.Id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DevType


class AcquisitionSpecsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Handshake=None, KV=None, MVDose=None, Gating=None):
        self.original_tagname_ = None
        self.Handshake = Handshake
        self.KV = KV
        self.MVDose = MVDose
        self.Gating = Gating
    def factory(*args_, **kwargs_):
        if AcquisitionSpecsType.subclass:
            return AcquisitionSpecsType.subclass(*args_, **kwargs_)
        else:
            return AcquisitionSpecsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Handshake(self): return self.Handshake
    def set_Handshake(self, Handshake): self.Handshake = Handshake
    def get_KV(self): return self.KV
    def set_KV(self, KV): self.KV = KV
    def get_MVDose(self): return self.MVDose
    def set_MVDose(self, MVDose): self.MVDose = MVDose
    def get_Gating(self): return self.Gating
    def set_Gating(self, Gating): self.Gating = Gating
    def validate_GatingType(self, value):
        # Validate type GatingType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Handshake is not None or
            self.KV is not None or
            self.MVDose is not None or
            self.Gating is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AcquisitionSpecsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcquisitionSpecsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AcquisitionSpecsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AcquisitionSpecsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AcquisitionSpecsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Handshake is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHandshake>%s</%sHandshake>%s' % (namespace_, self.gds_format_boolean(self.Handshake, input_name='Handshake'), namespace_, eol_))
        if self.KV is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKV>%s</%sKV>%s' % (namespace_, self.gds_format_boolean(self.KV, input_name='KV'), namespace_, eol_))
        if self.MVDose is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMVDose>%s</%sMVDose>%s' % (namespace_, self.gds_format_double(self.MVDose, input_name='MVDose'), namespace_, eol_))
        if self.Gating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGating>%s</%sGating>%s' % (namespace_, self.gds_format_string(quote_xml(self.Gating).encode(ExternalEncoding), input_name='Gating'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Handshake':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Handshake')
            self.Handshake = ival_
        elif nodeName_ == 'KV':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'KV')
            self.KV = ival_
        elif nodeName_ == 'MVDose':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MVDose')
            self.MVDose = fval_
        elif nodeName_ == 'Gating':
            Gating_ = child_.text
            Gating_ = self.gds_validate_string(Gating_, node, 'Gating')
            self.Gating = Gating_
            self.validate_GatingType(self.Gating)    # validate type GatingType
# end class AcquisitionSpecsType


class AcquisitionParametersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ImageMode=None, AcquisitionMode=None, CalibrationSet=None, ImageDestination=None, NotificationDestination=None, Movie=None, RaiseFault=None, Cache=None, HistogramRoi=None, MV=None, KV=None):
        self.original_tagname_ = None
        self.ImageMode = ImageMode
        self.AcquisitionMode = AcquisitionMode
        self.CalibrationSet = CalibrationSet
        if ImageDestination is None:
            self.ImageDestination = []
        else:
            self.ImageDestination = ImageDestination
        if NotificationDestination is None:
            self.NotificationDestination = []
        else:
            self.NotificationDestination = NotificationDestination
        self.Movie = Movie
        self.RaiseFault = RaiseFault
        self.Cache = Cache
        self.HistogramRoi = HistogramRoi
        self.MV = MV
        self.KV = KV
    def factory(*args_, **kwargs_):
        if AcquisitionParametersType.subclass:
            return AcquisitionParametersType.subclass(*args_, **kwargs_)
        else:
            return AcquisitionParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ImageMode(self): return self.ImageMode
    def set_ImageMode(self, ImageMode): self.ImageMode = ImageMode
    def get_AcquisitionMode(self): return self.AcquisitionMode
    def set_AcquisitionMode(self, AcquisitionMode): self.AcquisitionMode = AcquisitionMode
    def get_CalibrationSet(self): return self.CalibrationSet
    def set_CalibrationSet(self, CalibrationSet): self.CalibrationSet = CalibrationSet
    def get_ImageDestination(self): return self.ImageDestination
    def set_ImageDestination(self, ImageDestination): self.ImageDestination = ImageDestination
    def add_ImageDestination(self, value): self.ImageDestination.append(value)
    def insert_ImageDestination_at(self, index, value): self.ImageDestination.insert(index, value)
    def replace_ImageDestination_at(self, index, value): self.ImageDestination[index] = value
    def get_NotificationDestination(self): return self.NotificationDestination
    def set_NotificationDestination(self, NotificationDestination): self.NotificationDestination = NotificationDestination
    def add_NotificationDestination(self, value): self.NotificationDestination.append(value)
    def insert_NotificationDestination_at(self, index, value): self.NotificationDestination.insert(index, value)
    def replace_NotificationDestination_at(self, index, value): self.NotificationDestination[index] = value
    def get_Movie(self): return self.Movie
    def set_Movie(self, Movie): self.Movie = Movie
    def get_RaiseFault(self): return self.RaiseFault
    def set_RaiseFault(self, RaiseFault): self.RaiseFault = RaiseFault
    def get_Cache(self): return self.Cache
    def set_Cache(self, Cache): self.Cache = Cache
    def get_HistogramRoi(self): return self.HistogramRoi
    def set_HistogramRoi(self, HistogramRoi): self.HistogramRoi = HistogramRoi
    def get_MV(self): return self.MV
    def set_MV(self, MV): self.MV = MV
    def get_KV(self): return self.KV
    def set_KV(self, KV): self.KV = KV
    def hasContent_(self):
        if (
            self.ImageMode is not None or
            self.AcquisitionMode is not None or
            self.CalibrationSet is not None or
            self.ImageDestination or
            self.NotificationDestination or
            self.Movie is not None or
            self.RaiseFault is not None or
            self.Cache is not None or
            self.HistogramRoi is not None or
            self.MV is not None or
            self.KV is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AcquisitionParametersType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcquisitionParametersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AcquisitionParametersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AcquisitionParametersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AcquisitionParametersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ImageMode is not None:
            self.ImageMode.export(outfile, level, namespace_, name_='ImageMode', pretty_print=pretty_print)
        if self.AcquisitionMode is not None:
            self.AcquisitionMode.export(outfile, level, namespace_, name_='AcquisitionMode', pretty_print=pretty_print)
        if self.CalibrationSet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCalibrationSet>%s</%sCalibrationSet>%s' % (namespace_, self.gds_format_string(quote_xml(self.CalibrationSet).encode(ExternalEncoding), input_name='CalibrationSet'), namespace_, eol_))
        for ImageDestination_ in self.ImageDestination:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImageDestination>%s</%sImageDestination>%s' % (namespace_, self.gds_format_string(quote_xml(ImageDestination_).encode(ExternalEncoding), input_name='ImageDestination'), namespace_, eol_))
        for NotificationDestination_ in self.NotificationDestination:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNotificationDestination>%s</%sNotificationDestination>%s' % (namespace_, self.gds_format_string(quote_xml(NotificationDestination_).encode(ExternalEncoding), input_name='NotificationDestination'), namespace_, eol_))
        if self.Movie is not None:
            self.Movie.export(outfile, level, namespace_, name_='Movie', pretty_print=pretty_print)
        if self.RaiseFault is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRaiseFault>%s</%sRaiseFault>%s' % (namespace_, self.gds_format_boolean(self.RaiseFault, input_name='RaiseFault'), namespace_, eol_))
        if self.Cache is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCache>%s</%sCache>%s' % (namespace_, self.gds_format_boolean(self.Cache, input_name='Cache'), namespace_, eol_))
        if self.HistogramRoi is not None:
            self.HistogramRoi.export(outfile, level, namespace_, name_='HistogramRoi', pretty_print=pretty_print)
        if self.MV is not None:
            self.MV.export(outfile, level, namespace_, name_='MV', pretty_print=pretty_print)
        if self.KV is not None:
            self.KV.export(outfile, level, namespace_, name_='KV', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ImageMode':
            obj_ = ImageModeType.factory()
            obj_.build(child_)
            self.ImageMode = obj_
            obj_.original_tagname_ = 'ImageMode'
        elif nodeName_ == 'AcquisitionMode':
            obj_ = AcquisitionModeType.factory()
            obj_.build(child_)
            self.AcquisitionMode = obj_
            obj_.original_tagname_ = 'AcquisitionMode'
        elif nodeName_ == 'CalibrationSet':
            CalibrationSet_ = child_.text
            CalibrationSet_ = self.gds_validate_string(CalibrationSet_, node, 'CalibrationSet')
            self.CalibrationSet = CalibrationSet_
        elif nodeName_ == 'ImageDestination':
            ImageDestination_ = child_.text
            ImageDestination_ = self.gds_validate_string(ImageDestination_, node, 'ImageDestination')
            self.ImageDestination.append(ImageDestination_)
        elif nodeName_ == 'NotificationDestination':
            NotificationDestination_ = child_.text
            NotificationDestination_ = self.gds_validate_string(NotificationDestination_, node, 'NotificationDestination')
            self.NotificationDestination.append(NotificationDestination_)
        elif nodeName_ == 'Movie':
            obj_ = MovieType.factory()
            obj_.build(child_)
            self.Movie = obj_
            obj_.original_tagname_ = 'Movie'
        elif nodeName_ == 'RaiseFault':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'RaiseFault')
            self.RaiseFault = ival_
        elif nodeName_ == 'Cache':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Cache')
            self.Cache = ival_
        elif nodeName_ == 'HistogramRoi':
            obj_ = HistogramRoiType.factory()
            obj_.build(child_)
            self.HistogramRoi = obj_
            obj_.original_tagname_ = 'HistogramRoi'
        elif nodeName_ == 'MV':
            obj_ = MVType.factory()
            obj_.build(child_)
            self.MV = obj_
            obj_.original_tagname_ = 'MV'
        elif nodeName_ == 'KV':
            obj_ = KVType.factory()
            obj_.build(child_)
            self.KV = obj_
            obj_.original_tagname_ = 'KV'
# end class AcquisitionParametersType


class ImageModeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, Overwrite=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if Overwrite is None:
            self.Overwrite = []
        else:
            self.Overwrite = Overwrite
    def factory(*args_, **kwargs_):
        if ImageModeType.subclass:
            return ImageModeType.subclass(*args_, **kwargs_)
        else:
            return ImageModeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Overwrite(self): return self.Overwrite
    def set_Overwrite(self, Overwrite): self.Overwrite = Overwrite
    def add_Overwrite(self, value): self.Overwrite.append(value)
    def insert_Overwrite_at(self, index, value): self.Overwrite.insert(index, value)
    def replace_Overwrite_at(self, index, value): self.Overwrite[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Overwrite
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ImageModeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImageModeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ImageModeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ImageModeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ImageModeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Overwrite_ in self.Overwrite:
            Overwrite_.export(outfile, level, namespace_, name_='Overwrite', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Overwrite':
            obj_ = OverwriteType.factory()
            obj_.build(child_)
            self.Overwrite.append(obj_)
            obj_.original_tagname_ = 'Overwrite'
# end class ImageModeType


class OverwriteType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, parameter=None, valueOf_=None):
        self.original_tagname_ = None
        self.parameter = _cast(None, parameter)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if OverwriteType.subclass:
            return OverwriteType.subclass(*args_, **kwargs_)
        else:
            return OverwriteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_parameter(self): return self.parameter
    def set_parameter(self, parameter): self.parameter = parameter
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OverwriteType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OverwriteType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OverwriteType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OverwriteType'):
        if self.parameter is not None and 'parameter' not in already_processed:
            already_processed.add('parameter')
            outfile.write(' parameter=%s' % (self.gds_format_string(quote_attrib(self.parameter).encode(ExternalEncoding), input_name='parameter'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OverwriteType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameter', node)
        if value is not None and 'parameter' not in already_processed:
            already_processed.add('parameter')
            self.parameter = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OverwriteType


class AcquisitionModeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, Overwrite=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if Overwrite is None:
            self.Overwrite = []
        else:
            self.Overwrite = Overwrite
    def factory(*args_, **kwargs_):
        if AcquisitionModeType.subclass:
            return AcquisitionModeType.subclass(*args_, **kwargs_)
        else:
            return AcquisitionModeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Overwrite(self): return self.Overwrite
    def set_Overwrite(self, Overwrite): self.Overwrite = Overwrite
    def add_Overwrite(self, value): self.Overwrite.append(value)
    def insert_Overwrite_at(self, index, value): self.Overwrite.insert(index, value)
    def replace_Overwrite_at(self, index, value): self.Overwrite[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Overwrite
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AcquisitionModeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcquisitionModeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AcquisitionModeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AcquisitionModeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AcquisitionModeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Overwrite_ in self.Overwrite:
            Overwrite_.export(outfile, level, namespace_, name_='Overwrite', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Overwrite':
            obj_ = OverwriteType2.factory()
            obj_.build(child_)
            self.Overwrite.append(obj_)
            obj_.original_tagname_ = 'Overwrite'
# end class AcquisitionModeType


class OverwriteType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, parameter=None, valueOf_=None):
        self.original_tagname_ = None
        self.parameter = _cast(None, parameter)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if OverwriteType2.subclass:
            return OverwriteType2.subclass(*args_, **kwargs_)
        else:
            return OverwriteType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_parameter(self): return self.parameter
    def set_parameter(self, parameter): self.parameter = parameter
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OverwriteType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OverwriteType2')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OverwriteType2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OverwriteType2'):
        if self.parameter is not None and 'parameter' not in already_processed:
            already_processed.add('parameter')
            outfile.write(' parameter=%s' % (self.gds_format_string(quote_attrib(self.parameter).encode(ExternalEncoding), input_name='parameter'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OverwriteType2', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameter', node)
        if value is not None and 'parameter' not in already_processed:
            already_processed.add('parameter')
            self.parameter = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OverwriteType2


class MovieType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Destination=None, Parameters=None):
        self.original_tagname_ = None
        self.Destination = Destination
        self.Parameters = Parameters
    def factory(*args_, **kwargs_):
        if MovieType.subclass:
            return MovieType.subclass(*args_, **kwargs_)
        else:
            return MovieType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Destination(self): return self.Destination
    def set_Destination(self, Destination): self.Destination = Destination
    def get_Parameters(self): return self.Parameters
    def set_Parameters(self, Parameters): self.Parameters = Parameters
    def hasContent_(self):
        if (
            self.Destination is not None or
            self.Parameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MovieType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MovieType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MovieType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MovieType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MovieType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Destination is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDestination>%s</%sDestination>%s' % (namespace_, self.gds_format_string(quote_xml(self.Destination).encode(ExternalEncoding), input_name='Destination'), namespace_, eol_))
        if self.Parameters is not None:
            self.Parameters.export(outfile, level, namespace_, name_='Parameters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Destination':
            Destination_ = child_.text
            Destination_ = self.gds_validate_string(Destination_, node, 'Destination')
            self.Destination = Destination_
        elif nodeName_ == 'Parameters':
            obj_ = ParametersType.factory()
            obj_.build(child_)
            self.Parameters = obj_
            obj_.original_tagname_ = 'Parameters'
# end class MovieType


class ParametersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, width=None, height=None, frameRate=None, crop=None, invert=None, pixelValue0=None, pixelValue255=None, cutOff=None, weight=None):
        self.original_tagname_ = None
        self.width = width
        self.height = height
        self.frameRate = frameRate
        self.crop = crop
        self.invert = invert
        self.pixelValue0 = pixelValue0
        self.pixelValue255 = pixelValue255
        self.cutOff = cutOff
        self.weight = weight
    def factory(*args_, **kwargs_):
        if ParametersType.subclass:
            return ParametersType.subclass(*args_, **kwargs_)
        else:
            return ParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_height(self): return self.height
    def set_height(self, height): self.height = height
    def get_frameRate(self): return self.frameRate
    def set_frameRate(self, frameRate): self.frameRate = frameRate
    def get_crop(self): return self.crop
    def set_crop(self, crop): self.crop = crop
    def get_invert(self): return self.invert
    def set_invert(self, invert): self.invert = invert
    def get_pixelValue0(self): return self.pixelValue0
    def set_pixelValue0(self, pixelValue0): self.pixelValue0 = pixelValue0
    def get_pixelValue255(self): return self.pixelValue255
    def set_pixelValue255(self, pixelValue255): self.pixelValue255 = pixelValue255
    def get_cutOff(self): return self.cutOff
    def set_cutOff(self, cutOff): self.cutOff = cutOff
    def get_weight(self): return self.weight
    def set_weight(self, weight): self.weight = weight
    def hasContent_(self):
        if (
            self.width is not None or
            self.height is not None or
            self.frameRate is not None or
            self.crop is not None or
            self.invert is not None or
            self.pixelValue0 is not None or
            self.pixelValue255 is not None or
            self.cutOff is not None or
            self.weight is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ParametersType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParametersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ParametersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParametersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ParametersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.width is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swidth>%s</%swidth>%s' % (namespace_, self.gds_format_integer(self.width, input_name='width'), namespace_, eol_))
        if self.height is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sheight>%s</%sheight>%s' % (namespace_, self.gds_format_integer(self.height, input_name='height'), namespace_, eol_))
        if self.frameRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sframeRate>%s</%sframeRate>%s' % (namespace_, self.gds_format_double(self.frameRate, input_name='frameRate'), namespace_, eol_))
        if self.crop is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scrop>%s</%scrop>%s' % (namespace_, self.gds_format_boolean(self.crop, input_name='crop'), namespace_, eol_))
        if self.invert is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinvert>%s</%sinvert>%s' % (namespace_, self.gds_format_boolean(self.invert, input_name='invert'), namespace_, eol_))
        if self.pixelValue0 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spixelValue0>%s</%spixelValue0>%s' % (namespace_, self.gds_format_integer(self.pixelValue0, input_name='pixelValue0'), namespace_, eol_))
        if self.pixelValue255 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spixelValue255>%s</%spixelValue255>%s' % (namespace_, self.gds_format_integer(self.pixelValue255, input_name='pixelValue255'), namespace_, eol_))
        if self.cutOff is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scutOff>%s</%scutOff>%s' % (namespace_, self.gds_format_integer(self.cutOff, input_name='cutOff'), namespace_, eol_))
        if self.weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sweight>%s</%sweight>%s' % (namespace_, self.gds_format_double(self.weight, input_name='weight'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'width':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'width')
            self.width = ival_
        elif nodeName_ == 'height':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'height')
            self.height = ival_
        elif nodeName_ == 'frameRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'frameRate')
            self.frameRate = fval_
        elif nodeName_ == 'crop':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'crop')
            self.crop = ival_
        elif nodeName_ == 'invert':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'invert')
            self.invert = ival_
        elif nodeName_ == 'pixelValue0':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'pixelValue0')
            self.pixelValue0 = ival_
        elif nodeName_ == 'pixelValue255':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'pixelValue255')
            self.pixelValue255 = ival_
        elif nodeName_ == 'cutOff':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cutOff')
            self.cutOff = ival_
        elif nodeName_ == 'weight':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'weight')
            self.weight = fval_
# end class ParametersType


class HistogramRoiType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, X1=None, Y1=None, X2=None, Y2=None):
        self.original_tagname_ = None
        self.X1 = X1
        self.Y1 = Y1
        self.X2 = X2
        self.Y2 = Y2
    def factory(*args_, **kwargs_):
        if HistogramRoiType.subclass:
            return HistogramRoiType.subclass(*args_, **kwargs_)
        else:
            return HistogramRoiType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X1(self): return self.X1
    def set_X1(self, X1): self.X1 = X1
    def get_Y1(self): return self.Y1
    def set_Y1(self, Y1): self.Y1 = Y1
    def get_X2(self): return self.X2
    def set_X2(self, X2): self.X2 = X2
    def get_Y2(self): return self.Y2
    def set_Y2(self, Y2): self.Y2 = Y2
    def hasContent_(self):
        if (
            self.X1 is not None or
            self.Y1 is not None or
            self.X2 is not None or
            self.Y2 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HistogramRoiType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HistogramRoiType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HistogramRoiType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HistogramRoiType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HistogramRoiType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX1>%s</%sX1>%s' % (namespace_, self.gds_format_integer(self.X1, input_name='X1'), namespace_, eol_))
        if self.Y1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sY1>%s</%sY1>%s' % (namespace_, self.gds_format_integer(self.Y1, input_name='Y1'), namespace_, eol_))
        if self.X2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX2>%s</%sX2>%s' % (namespace_, self.gds_format_integer(self.X2, input_name='X2'), namespace_, eol_))
        if self.Y2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sY2>%s</%sY2>%s' % (namespace_, self.gds_format_integer(self.Y2, input_name='Y2'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X1':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'X1')
            self.X1 = ival_
        elif nodeName_ == 'Y1':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Y1')
            self.Y1 = ival_
        elif nodeName_ == 'X2':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'X2')
            self.X2 = ival_
        elif nodeName_ == 'Y2':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Y2')
            self.Y2 = ival_
# end class HistogramRoiType


class MVType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Energy=None, DoseRate=None):
        self.original_tagname_ = None
        self.Energy = Energy
        self.DoseRate = DoseRate
    def factory(*args_, **kwargs_):
        if MVType.subclass:
            return MVType.subclass(*args_, **kwargs_)
        else:
            return MVType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Energy(self): return self.Energy
    def set_Energy(self, Energy): self.Energy = Energy
    def get_DoseRate(self): return self.DoseRate
    def set_DoseRate(self, DoseRate): self.DoseRate = DoseRate
    def hasContent_(self):
        if (
            self.Energy is not None or
            self.DoseRate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MVType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MVType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MVType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MVType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MVType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Energy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnergy>%s</%sEnergy>%s' % (namespace_, self.gds_format_string(quote_xml(self.Energy).encode(ExternalEncoding), input_name='Energy'), namespace_, eol_))
        if self.DoseRate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDoseRate>%s</%sDoseRate>%s' % (namespace_, self.gds_format_double(self.DoseRate, input_name='DoseRate'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Energy':
            Energy_ = child_.text
            Energy_ = self.gds_validate_string(Energy_, node, 'Energy')
            self.Energy = Energy_
        elif nodeName_ == 'DoseRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'DoseRate')
            self.DoseRate = fval_
# end class MVType


class KVType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, KiloVolts=None, MilliAmperes=None, MilliSeconds=None, eFocalSpot='Large', eFluoroLevelControl='Low', AutoBrightnessControl=False):
        self.original_tagname_ = None
        self.KiloVolts = KiloVolts
        self.MilliAmperes = MilliAmperes
        self.MilliSeconds = MilliSeconds
        self.eFocalSpot = eFocalSpot
        self.eFluoroLevelControl = eFluoroLevelControl
        self.AutoBrightnessControl = AutoBrightnessControl
    def factory(*args_, **kwargs_):
        if KVType.subclass:
            return KVType.subclass(*args_, **kwargs_)
        else:
            return KVType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KiloVolts(self): return self.KiloVolts
    def set_KiloVolts(self, KiloVolts): self.KiloVolts = KiloVolts
    def get_MilliAmperes(self): return self.MilliAmperes
    def set_MilliAmperes(self, MilliAmperes): self.MilliAmperes = MilliAmperes
    def get_MilliSeconds(self): return self.MilliSeconds
    def set_MilliSeconds(self, MilliSeconds): self.MilliSeconds = MilliSeconds
    def get_eFocalSpot(self): return self.eFocalSpot
    def set_eFocalSpot(self, eFocalSpot): self.eFocalSpot = eFocalSpot
    def get_eFluoroLevelControl(self): return self.eFluoroLevelControl
    def set_eFluoroLevelControl(self, eFluoroLevelControl): self.eFluoroLevelControl = eFluoroLevelControl
    def get_AutoBrightnessControl(self): return self.AutoBrightnessControl
    def set_AutoBrightnessControl(self, AutoBrightnessControl): self.AutoBrightnessControl = AutoBrightnessControl
    def validate_eFocalSpotType(self, value):
        # Validate type eFocalSpotType, a restriction on xs:string.
        pass
    def validate_eFluoroLevelControlType(self, value):
        # Validate type eFluoroLevelControlType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.KiloVolts is not None or
            self.MilliAmperes is not None or
            self.MilliSeconds is not None or
            self.eFocalSpot is not None or
            self.eFluoroLevelControl is not None or
            self.AutoBrightnessControl is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KVType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KVType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KVType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KVType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KVType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.KiloVolts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKiloVolts>%s</%sKiloVolts>%s' % (namespace_, self.gds_format_double(self.KiloVolts, input_name='KiloVolts'), namespace_, eol_))
        if self.MilliAmperes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMilliAmperes>%s</%sMilliAmperes>%s' % (namespace_, self.gds_format_double(self.MilliAmperes, input_name='MilliAmperes'), namespace_, eol_))
        if self.MilliSeconds is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMilliSeconds>%s</%sMilliSeconds>%s' % (namespace_, self.gds_format_double(self.MilliSeconds, input_name='MilliSeconds'), namespace_, eol_))
        if self.eFocalSpot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seFocalSpot>%s</%seFocalSpot>%s' % (namespace_, self.gds_format_string(quote_xml(self.eFocalSpot).encode(ExternalEncoding), input_name='eFocalSpot'), namespace_, eol_))
        if self.eFluoroLevelControl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seFluoroLevelControl>%s</%seFluoroLevelControl>%s' % (namespace_, self.gds_format_string(quote_xml(self.eFluoroLevelControl).encode(ExternalEncoding), input_name='eFluoroLevelControl'), namespace_, eol_))
        if self.AutoBrightnessControl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAutoBrightnessControl>%s</%sAutoBrightnessControl>%s' % (namespace_, self.gds_format_boolean(self.AutoBrightnessControl, input_name='AutoBrightnessControl'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KiloVolts':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'KiloVolts')
            self.KiloVolts = fval_
        elif nodeName_ == 'MilliAmperes':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MilliAmperes')
            self.MilliAmperes = fval_
        elif nodeName_ == 'MilliSeconds':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MilliSeconds')
            self.MilliSeconds = fval_
        elif nodeName_ == 'eFocalSpot':
            eFocalSpot_ = child_.text
            eFocalSpot_ = self.gds_validate_string(eFocalSpot_, node, 'eFocalSpot')
            self.eFocalSpot = eFocalSpot_
            self.validate_eFocalSpotType(self.eFocalSpot)    # validate type eFocalSpotType
        elif nodeName_ == 'eFluoroLevelControl':
            eFluoroLevelControl_ = child_.text
            eFluoroLevelControl_ = self.gds_validate_string(eFluoroLevelControl_, node, 'eFluoroLevelControl')
            self.eFluoroLevelControl = eFluoroLevelControl_
            self.validate_eFluoroLevelControlType(self.eFluoroLevelControl)    # validate type eFluoroLevelControlType
        elif nodeName_ == 'AutoBrightnessControl':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AutoBrightnessControl')
            self.AutoBrightnessControl = ival_
# end class KVType


class PositionsType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Lat=None, Lng=None, Vrt=None, Pitch=None):
        self.original_tagname_ = None
        self.Lat = Lat
        self.Lng = Lng
        self.Vrt = Vrt
        self.Pitch = Pitch
    def factory(*args_, **kwargs_):
        if PositionsType3.subclass:
            return PositionsType3.subclass(*args_, **kwargs_)
        else:
            return PositionsType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Lat(self): return self.Lat
    def set_Lat(self, Lat): self.Lat = Lat
    def get_Lng(self): return self.Lng
    def set_Lng(self, Lng): self.Lng = Lng
    def get_Vrt(self): return self.Vrt
    def set_Vrt(self, Vrt): self.Vrt = Vrt
    def get_Pitch(self): return self.Pitch
    def set_Pitch(self, Pitch): self.Pitch = Pitch
    def hasContent_(self):
        if (
            self.Lat is not None or
            self.Lng is not None or
            self.Vrt is not None or
            self.Pitch is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PositionsType3', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PositionsType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PositionsType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PositionsType3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PositionsType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Lat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLat>%s</%sLat>%s' % (namespace_, self.gds_format_double(self.Lat, input_name='Lat'), namespace_, eol_))
        if self.Lng is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLng>%s</%sLng>%s' % (namespace_, self.gds_format_double(self.Lng, input_name='Lng'), namespace_, eol_))
        if self.Vrt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVrt>%s</%sVrt>%s' % (namespace_, self.gds_format_double(self.Vrt, input_name='Vrt'), namespace_, eol_))
        if self.Pitch is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPitch>%s</%sPitch>%s' % (namespace_, self.gds_format_double(self.Pitch, input_name='Pitch'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Lat':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Lat')
            self.Lat = fval_
        elif nodeName_ == 'Lng':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Lng')
            self.Lng = fval_
        elif nodeName_ == 'Vrt':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Vrt')
            self.Vrt = fval_
        elif nodeName_ == 'Pitch':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Pitch')
            self.Pitch = fval_
# end class PositionsType3


GDSClassesMapping = {
    'Parameters': ParametersType,
    'AcquisitionStart': Acquisition,
    'HistogramRoi': HistogramRoiType,
    'Movie': MovieType,
    'MvdAfter': ArmPositionsType,
    'Position': PositionType,
    'KvBlades': KvBladesType1,
    'AcquisitionMode': AcquisitionModeType,
    'KvFilters': KvFiltersType,
    'KvsAfter': ArmPositionsType,
    'Kvd': ArmTolerances,
    'ImagingParameters': ImagingParametersType,
    'VelTable': VelTableType,
    'ImagingTolerances': ImagingTolerancesType,
    'KVAcquisitionTrigger': KVAcquisitionTriggerType,
    'DuringTreatment': DuringTreatmentType,
    'SubBeam': SubBeamType,
    'MV': MVType,
    'Kvs': ArmTolerances,
    'AcquisitionParameters': AcquisitionParametersType,
    'AcquisitionSpecs': AcquisitionSpecsType,
    'Overwrite': OverwriteType2,
    'Mlc': MlcType,
    'AcquisitionStop': Acquisition,
    'Tracking': TrackingType,
    'ImagingPoints': ImagingPointsType,
    'GatingWindow': GatingWindowType,
    'Positions': PositionsType,
    'GatingParameters': GatingParametersType,
    'Dev': DevType,
    'KvdAfter': ArmPositionsType,
    'OutsideTreatment': OutsideTreatmentType,
    'Mvd': ArmTolerances,
    'ImageMode': ImageModeType,
    'ImagingPoint': ImagingPointType,
    'ControlPoints': ControlPointsType,
    'BeamHoldDevices': BeamHoldDevicesType,
    'Orientation': OrientationType,
    'ImagingVelTable': ImagingVelTableType,
    'TolTable': TolTableType,
    'KV': KVType,
    'MVAcquisitionTrigger': MVAcquisitionTriggerType,
    'Cp': CpType,
    'Accs': AccsType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'VarianResearchBeam'
        rootClass = VarianResearchBeam
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'VarianResearchBeam'
        rootClass = VarianResearchBeam
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'VarianResearchBeam'
        rootClass = VarianResearchBeam
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'VarianResearchBeam'
        rootClass = VarianResearchBeam
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from developer_mode import *\n\n')
        sys.stdout.write('import developer_mode as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AccsType",
    "Acquisition",
    "AcquisitionModeType",
    "AcquisitionParametersType",
    "AcquisitionSpecsType",
    "AcquisitionTrigger",
    "ArmPositionsType",
    "ArmTolerances",
    "BeamHoldDevicesType",
    "ControlPointsType",
    "CpType",
    "DevType",
    "DuringTreatmentType",
    "GatingParametersType",
    "GatingWindowType",
    "HistogramRoiType",
    "ImageModeType",
    "ImagingParametersType",
    "ImagingPointType",
    "ImagingPointsType",
    "ImagingTolerancesType",
    "ImagingVelTableType",
    "KVAcquisitionTriggerType",
    "KVType",
    "KvBladesType",
    "KvBladesType1",
    "KvFiltersType",
    "MVAcquisitionTriggerType",
    "MVType",
    "MlcType",
    "MovieType",
    "OrientationType",
    "OutsideTreatmentType",
    "OverwriteType",
    "OverwriteType2",
    "ParametersType",
    "PositionType",
    "PositionsType",
    "PositionsType3",
    "SetBeam",
    "SubBeamType",
    "TolTableType",
    "TrackingType",
    "VarianResearchBeam",
    "VelTableType"
]
